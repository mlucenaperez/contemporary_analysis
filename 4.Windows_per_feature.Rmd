---
title: "4.Windows_per_feature"
output: html_document
---

Test to see whether we could concatenate all the features and run a window approach over it.


# 1. Get position for every feature:

```{bash}

mkdir /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/
#c_lp_sm_n012 --> done
#c_lp_do_n012 --> done
#c_ll_ki_n008 --> done
#c_ll_no_n008 --> done
#c_ll_po_n008 --> done

POP=c_ll_po_n008 # <--- Change pop here!
screen -S "$POP"_get_feature_coordinates
POP=c_ll_po_n008 # <--- Change pop here!
script log_screen_"$POP"_get_feature_coordinates.log
POP=c_ll_po_n008 # <--- Change pop here!

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs

## Variables
SCAFFOLDS_FOLDER=/GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3.PerScaffold/
FEATURE_POSITIONS_FOLDER=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/
SFS_FOLDER=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/
OUTPUT_DIR=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature
REF="/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated"

FEATURES=(CDS UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

echo "---------------------------------------------------$POP---------------------------------------------------"

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
for iteration in {1..10}
do
rm "${OUTPUT_DIR}"/"${POP}".transformedThetas_iteration"$iteration"."${FEATURE}"
SCAFFOLD_START=$( echo '1 + 4170 * ('$iteration' - 1)' | bc)
SCAFFOLD_END=$( echo '4170 * '$iteration | bc )
for SCAFFOLD_NUMBER in $(seq -s " " -f %05g $SCAFFOLD_START $SCAFFOLD_END) # esta manera de hacer seq te va a sacar siempre 5 cifras.
do
SCAFFOLD=$(echo "lp23.s"$SCAFFOLD_NUMBER)
cd "$SFS_FOLDER""$POP"_separated_by_scaffold
cat "$POP".transformedThetas_"$SCAFFOLD" | bedtools intersect -a stdin -b <( cat "$SCAFFOLDS_FOLDER"LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3_"$SCAFFOLD" | grep $'\t'$FEATURE$'\t' ) -sorted -g $REF | awk -v OFS='\t' '{print $1, $2, $3, $4, $5}' >> "${OUTPUT_DIR}"/"${POP}".transformedThetas_iteration"$iteration"."${FEATURE}"
done &
done 
done

```

# 2. Get common positions among pops

We are using the intermediate interaction files to avoid large files.
Ojo! A veces la misma posición aparece dos veces porque puede ser por ejemplo 3UTR de un gen y 3UTR de otro 
Por ejemplo en iteration1, 3UTR, don y smo

lp23.s00270	67343	67344
lp23.s00270	67343	67344

Esta posición aparece doble porque:

lp23.s00270 EVM_PASA3UTR66285   67354   .   -   .   ID=LYPA23C021224
lp23.s00270 EVM_PASA3UTR66569   68521   .   +   .   ID=LYPA23C021227

Está dentro de dos UTR distintos. Así que antes de filtrar hago uniq para asegurarme que no las meto dobles. 

## Bedtools approach

```{bash}
cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

REF="/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated"
OUTPUT_DIR=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature
FEATURES=(CDS UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
for iteration in {1..10}
do
echo $iteration
echo "doing lynx pardinus"
bedtools intersect \
-a <(cat c_lp_sm_n012.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}' | uniq ) \
-b <(cat c_lp_do_n012.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}' | uniq ) \
-sorted -g $REF > c_lp_iteration"$iteration"."${FEATURE}".innercoordinates

# Filter do for the coordinates in common.
bedtools intersect \
-a <(cat "${OUTPUT_DIR}"/c_lp_do_n012.transformedThetas_iteration"$iteration"."${FEATURE}" | uniq ) \
-b <(cat c_lp_iteration"$iteration"."${FEATURE}".innercoordinates) \
-sorted -g $REF > "${OUTPUT_DIR}"/c_lp_do_n012.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter sm for the coordinates in common.
bedtools intersect \
-a <(cat "${OUTPUT_DIR}"/c_lp_sm_n012.transformedThetas_iteration"$iteration"."${FEATURE}" | uniq) \
-b <(cat c_lp_iteration"$iteration"."${FEATURE}".innercoordinates) \
-sorted -g $REF > "${OUTPUT_DIR}"/c_lp_sm_n012.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

echo "doing lynx lynx"

## LYNX LYNX ## ## ## ## ## 
# I am doing a inner join:
# I am doing it in 3 different steps althougth I would need it, because, when I get to ll I will need to do it like that, or it will be more complex.
# 1. Get coordinates in common for the three pop.
bedtools intersect \
-a <(cat c_ll_ki_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}' | uniq) \
-b <(cat c_ll_po_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}' | uniq) \
-sorted -g $REF |\
bedtools intersect \
-a - \
-b <(cat c_ll_no_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}' | uniq) \
-sorted -g $REF > c_ll_iteration"$iteration"."${FEATURE}".innercoordinates

# Filter ki for the coordinates in common.
bedtools intersect \
-a <(cat "${OUTPUT_DIR}"/c_ll_ki_n008.transformedThetas_iteration"$iteration"."${FEATURE}" | uniq ) \
-b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_ki_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter no for the coordinates in common.
bedtools intersect \
-a <(cat "${OUTPUT_DIR}"/c_ll_no_n008.transformedThetas_iteration"$iteration"."${FEATURE}" | uniq) \
-b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_no_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter po for the coordinates in common.
bedtools intersect \
-a <(cat "${OUTPUT_DIR}"/c_ll_po_n008.transformedThetas_iteration"$iteration"."${FEATURE}" | uniq) \
-b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_po_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

done
done

# Teniendo en cuenta que necesito hacer uniq compruebo un par de features

wc -l c_lp*iteration*
wc -l c_ll*iteration*

# Para pardinus tiene buena pinta!
rm c_lp_iteration*.innercoordinates

FEATURES=(CDS UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
#rm c_ll_ki_n008.transformedThetas_iteration{1..10}."${FEATURE}"
#rm c_ll_po_n008.transformedThetas_iteration{1..10}."${FEATURE}"
#rm c_ll_no_n008.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_lp_sm_n012.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_lp_do_n012.transformedThetas_iteration{1..10}."${FEATURE}"
done


```

## X and autosomes file

I have to create a filter to filter for with the scaffolds associated to X chr and the scaffold associated with autosomes. 
```{bash}
cd /GRUPOS/grupolince/copia_fabascal/MAPPINGS/

awk '{print $1}' lynx2cat_wTiger_Xchr.sorted.merged.bed | sort | uniq > scaffold_Xchr_putatively
wc -l scaffold_Xchr_putatively
#1891 scaffold_X
# Those would be the scaffolds associated to Xchr, however! some of those are also present in autosomes, so I should filter them. 
grep -f scaffold_Xchr_putatively lynx2cat_wTiger_AUTOSOMALchr.sorted.merged.corrected.bed | awk '{print $1}' | sort | uniq > scaffold_X_Autosomes
wc -l scaffold_X_Autosomes
#250 scaffold_X_Autosomes

grep -v -f scaffold_X_Autosomes scaffold_Xchr > scaffold_Xchr_exclusively
wc -l scaffold_Xchr_exclusively
#1641 scaffold_Xchr_exclusively

# He guardado un README con esta info en la capeta. 

rm scaffold_X_Autosomes
# Vamos a usar el scaffold_Xchr_putatively para quitarnos todo lo que pudiera ser X del analisis de autosomico y scaffold_Xchr_exclusively para hacer el análisis de los X. 

# As I will use them with bedtools intersect, I need to add some coordinates. To do so I will grep those scaffold in lp23.lenght file and add the complete chr.

grep -f /GRUPOS/grupolince/copia_fabascal/MAPPINGS/scaffold_Xchr_exclusively /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated > /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr


grep -v -f /GRUPOS/grupolince/copia_fabascal/MAPPINGS/scaffold_Xchr_putatively /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated > /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes


```

As I thought about this filter after doing already some features, I have two different approaches right now. 

1. Filter the scaffolds before cat (intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000 3UTR UCNE 5UTR intergenic CDS).
2. Filter the scaffolds already in the transformed filtered file (3UTR UCNE 5UTR intergenic CDS intron).

What I am doing is:

Using the scaffold only assing to X chr to get X coordinates. However! I will use scaffold assinged to X OR X&Autosomes to filter all the scaffold. 
i.e.

X= scaffolds Assing only to X 
Autosomes= All scaffolds - (scaffold assigned to x OR to x & autosomes).

Los archivos son:

/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr
/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes

# Join all filtered iteractions and assign consecutive coordinates to a file

```{bash}

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

REF=/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated
FEATURES=(CDS UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)
POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 )



for FEATURE in "${FEATURES[@]}"
do
for POP in "${POPS[@]}"
do

rm "$POP".transformedThetas.filtered.Xchr."${FEATURE}"
rm "$POP".transformedThetas.filtered.Auto."${FEATURE}"

# join all files

for iteration in {1..10}
do

echo "Doing "$FEATURE $POP $iteration 

bedtools intersect -a "$POP".transformedThetas_iteration$iteration.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr) -sorted -g $REF > "$POP".transformedThetas_iteration$iteration.filtered.Xchr."${FEATURE}"

bedtools intersect -a "$POP".transformedThetas_iteration$iteration.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes) -sorted -g $REF > "$POP".transformedThetas_iteration$iteration.filtered.auto."${FEATURE}"

done
echo "finish filtering, ready to cat"
rm "$POP".transformedThetas_iteration{1..10}.filtered."${FEATURE}"

cat "$POP".transformedThetas_iteration{1..10}.filtered.Xchr."${FEATURE}" >> "$POP".transformedThetas.filtered.Xchr."${FEATURE}"
cat "$POP".transformedThetas_iteration{1..10}.filtered.auto."${FEATURE}" >> "$POP".transformedThetas.filtered.auto."${FEATURE}"

rm "$POP".transformedThetas_iteration{1..10}.filtered.Xchr."${FEATURE}"
rm "$POP".transformedThetas_iteration{1..10}.filtered.auto."${FEATURE}"

echo "Done with" $POP "and" $FEATURE

done
done

```


# Store files & move

```{bash}
mkdir /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis
mkdir /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/raw_data
cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/

mv *filtered* raw_data
mv raw_data/*window* .

tar -czvf raw_files_for_window_analysis.tar.gz raw_data

mv raw_files_for_window_analysis.tar.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis 

```

#  Script calculate window

Generate script to get all data of interest for each window.

He preguntado y esta es la respuesta
https://stackoverflow.com/questions/61938028/group-by-one-column-find-min-and-max-values-based-on-that-column-and-calculate#61939415

window_10000_5000.awk
```{awk}
BEGIN {
winSize = 10000
winStep = 5000
OFS = "\t"
}
{ buf[NR % winSize] = $0 }
(NR % winStep) == 0 { if (NR>=winSize) prt() }

function prt(   sum,f,i,idx,beg,end,key,numKeys,keyNr,ranges) {
for (i=1; i<=winSize; i++) {
idx = (NR+i) % winSize
split(buf[idx],f)

key = f[1]
if ( !(key in beg) ) {
keys[++numKeys] = key
beg[key] = f[2]
}
end[key] = f[3]

sum[4] += f[4]
sum[5] += f[5]
}

for ( keyNr=1; keyNr<=numKeys; keyNr++ ) {
key = keys[keyNr]
ranges = (keyNr > 1 ? ranges ";" : "") key "_" beg[key] "_" end[key]
}

print NR, ranges, sum[4] / winSize, sum[5] / winSize
}
```


# Iterate over pops and feature.

```{bash}
cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/raw_data

POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 c_lp_do_n012 c_lp_sm_n012)
FEATURES=(CDS UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)
window_size=10000
window_step=5000

for POP in "${POPS[@]}"
do 
#echo -e 'window\tscaffold_pos1_pos2\tave_watterson\tave_pairwise\tfeature\tpop' > ../$POP.transformedThetas.filtered.auto.window_"${window_size}"_"${window_step}" 
echo -e 'window\tscaffold_pos1_pos2\tave_watterson\tave_pairwise\tfeature\tpop' > ../$POP.transformedThetas.filtered.Xchr.window_"${window_size}"_"${window_step}" 
for FEATURE in "${FEATURES[@]}"
do
#echo $POP $FEATURE "autosome"
#awk -f ../window_"${window_size}"_"${window_step}".awk $POP.transformedThetas.filtered.auto.$FEATURE  | awk -v OFS="\t" -v FEATURE="$FEATURE" -v POP="$POP" '{print $1, $2, $3, $4, FEATURE, POP}' >> ../$POP.transformedThetas.filtered.auto.window_"${window_size}"_"${window_step}"
echo $POP $FEATURE "Xchr"
awk -f ../window_"${window_size}"_"${window_step}".awk $POP.transformedThetas.filtered.Xchr.$FEATURE  | awk -v OFS="\t" -v FEATURE="$FEATURE" -v POP="$POP" '{print $1, $2, $3, $4, FEATURE, POP}' >> ../$POP.transformedThetas.filtered.Xchr.window_"${window_size}"_"${window_step}" 
done
done

```

# Download to local

```{bash}
window_size=10000
window_step=5000

scp -p mlucena@genomics-b.ebd.csic.es:/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/*window*"${window_size}"_"${window_step}" /Users/marialucenaperez/Documents/WG_lynx_diversity_per_windows_features/raw
```

# R
# Create dataframes

## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(psych)
library(ggpubr)
library(boot)
library(broom)
library(ggpubr)
library(ggrepel)
library(ggpmisc)
library(gridExtra)
library(mgcv)
library(MuMIn)
library(stringr)


sample.wtd.mean <- function(x, w, d) {
return(weighted.mean(x = x[d], w = w[d], na.rm=T ))
}

wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/"
wd_input <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_windows_features/raw/"
wd_input_common_fiels <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
```

## Load pre-data

```{r}
window_size=10000
window_step=5000

c_ll_ki_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_ki_n008.transformedThetas.filtered.auto.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[1]) %>% mutate (type_chr="autosomes") %>% mutate (Population="Kirov") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% filter (scaffold_pos1_pos2!="scaffold_pos1_pos2") %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_ll_no_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_no_n008.transformedThetas.filtered.auto.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color = viridis_pal()(5)[2]) %>% mutate (type_chr="autosomes") %>% mutate (Population="Norway") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_ll_po_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_po_n008.transformedThetas.filtered.auto.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[3]) %>% mutate (type_chr="autosomes") %>% mutate (Population="Poland") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_lp_sm_n012_diversity_windows_auto <- read.csv(paste(wd_input, "c_lp_sm_n012.transformedThetas.filtered.auto.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#5DC863FF") %>% mutate (type_chr="autosomes") %>% mutate (Population="Andujar") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr))%>% filter (scaffold_pos1_pos2!="scaffold_pos1_pos2") %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_lp_do_n012_diversity_windows_auto <- read.csv(paste(wd_input, "c_lp_do_n012.transformedThetas.filtered.auto.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#FDE725FF") %>% mutate (type_chr="autosomes") %>% mutate (Population="Donana") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))


### 

c_ll_ki_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_ki_n008.transformedThetas.filtered.Xchr.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[1]) %>% mutate (type_chr="chrX") %>% mutate (Population="Kirov") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr))%>% filter (scaffold_pos1_pos2!="scaffold_pos1_pos2") %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_ll_no_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_no_n008.transformedThetas.filtered.Xchr.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color = viridis_pal()(5)[2]) %>% mutate (type_chr="chrX") %>% mutate (Population="Norway") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_ll_po_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_po_n008.transformedThetas.filtered.Xchr.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[3]) %>% mutate (type_chr="chrX") %>% mutate (Population="Poland") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_lp_sm_n012_diversity_windows_X <- read.csv(paste(wd_input, "c_lp_sm_n012.transformedThetas.filtered.Xchr.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#5DC863FF") %>% mutate (type_chr="chrX") %>% mutate (Population="Andujar") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr))%>% filter (scaffold_pos1_pos2!="scaffold_pos1_pos2") %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

c_lp_do_n012_diversity_windows_X <- read.csv(paste(wd_input, "c_lp_do_n012.transformedThetas.filtered.Xchr.window_", window_size ,"_", window_step, sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#FDE725FF") %>% mutate (type_chr="chrX") %>% mutate (Population="Donana") %>% mutate (feature=as.factor(feature)) %>% mutate(window_id=paste0(window,".",feature,".",type_chr)) %>% mutate (ave_watterson = as.numeric (ave_watterson)) %>% mutate (ave_pairwise = as.numeric (ave_pairwise))

# Creo unos archivos para anotarlos, basados solo en una población de cada specie, ya que nosotros hemos filtrado las ventanas a nivel de specie (es deicr todas las poblaciones de la misma specie tienen las mismas ventanas)
lynxlynx_window_id <- rbind (c_ll_ki_n008_diversity_windows_X, c_ll_ki_n008_diversity_windows_auto) %>% select (window_id, scaffold_pos1_pos2)
lynxpardinus_window_id <- rbind (c_lp_sm_n012_diversity_windows_X, c_lp_sm_n012_diversity_windows_auto) %>% select (window_id, scaffold_pos1_pos2)

```

## Annotation

```{r}

common_fields <- read.csv(paste(wd_input_common_fiels, "common_fields_per_unit", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep=";", dec=",") 
setDT(common_fields)
common_fields<- as.data.table(common_fields)
setkey(common_fields, scaffold, start_cero_based, end )

DATAFRAMES=c("lynxlynx_window_id", "lynxpardinus_window_id")

for (DATAFRAME_USED in DATAFRAMES) 
{

NAME=DATAFRAME_USED  
df <-get (DATAFRAME_USED)
# sacar la tabla con la minima info.
df$number_of_scaffold <- str_count(df$scaffold_pos1_pos2, ";")+1
df_withScaffold_info <- df %>% 
  separate(scaffold_pos1_pos2, paste0("V", seq(max (df$number_of_scaffold))), extra = "merge", fill = "right", sep=";") %>% 
  select (-number_of_scaffold) %>% 
  gather (.,key = "variable", value="scaffold_position", -window_id ) %>%  
  select (-variable) %>% 
  drop_na (scaffold_position) %>% 
  separate (scaffold_position, c("scaffold", "pos1", "pos2"), extra = "merge", fill = "right", sep="_") %>% 
  mutate (informative_sites = as.numeric(pos2)-as.numeric(pos1) ) 
df_withScaffold_info$pos1 <- as.numeric(df_withScaffold_info$pos1)
df_withScaffold_info$pos2 <- as.numeric(df_withScaffold_info$pos2)
# Set as data.table
setDT(df_withScaffold_info)
df_withScaffold_info <-as.data.table(df_withScaffold_info)
setkey(df_withScaffold_info, scaffold, pos1, pos2 )
# Overlapp between datasets
a <-foverlaps(as.data.table(common_fields), as.data.table(df_withScaffold_info), type="any", nomatch=0L, mult="all")  %>%  
  separate(window_id , c("window", "FEATURE", "TYPE_CHR"), "[.]", extra = "merge") %>% 
  mutate (window_id=paste0(window,".", FEATURE,".", TYPE_CHR)) %>% 
  filter(FEATURE==feature & TYPE_CHR==type_chr) %>% 
  mutate (overlapping_bases = 
            as.numeric(
            # Option 1 (feature within window)
            ifelse ( start_cero_based > pos1 & end < pos2, end - start_cero_based,
            ifelse ( start_cero_based == pos1 & end < pos2, end - start_cero_based,
            ifelse ( start_cero_based > pos1 & end == pos2, end - start_cero_based, 
            # Option 2 (feature before window)
            ifelse ( start_cero_based < pos1 & end < pos2, end - pos1,
            ifelse ( start_cero_based < pos1 & end == pos2, end - pos1,
            # Option 3 (feature after window)
            ifelse ( start_cero_based > pos1 & end > pos2, pos2 - start_cero_based,
            ifelse ( start_cero_based == pos1 & end > pos2, pos2 - start_cero_based,
            # Option 4 (feature larger than window)
            ifelse ( start_cero_based < pos1 & end > pos2, pos2 - pos1,
            # Option 5 (feature=window)
            ifelse ( start_cero_based == pos1 & end == pos2, pos2 - pos1, "NA"))))))))))
          ) %>% 
  group_by (window_id) %>% 
  summarise (divergence_weighted = weighted.mean (divergence, overlapping_bases, na.rm = TRUE),
             recombination_weighted = weighted.mean (recombination_rate, overlapping_bases, na.rm = TRUE),
             GC_content_weighted = weighted.mean (GC_content, overlapping_bases, na.rm = TRUE),
             rvis_score_weighted = weighted.mean (rvis_score, overlapping_bases, na.rm = TRUE),
             centr_percentage_weighted = weighted.mean (centr_percentage, overlapping_bases, na.rm = TRUE),  
             tel10m_percentage_weighted = weighted.mean (tel10m_percentage, overlapping_bases, na.rm = TRUE),
             tel2m_percentage_weighted = weighted.mean (tel2m_percentage, overlapping_bases, na.rm = TRUE),
             region_collapse = paste (unique(region), collapse = ','), 
             chr_collapse = paste (unique(chr), collapse = ','),
             unique_id_collapse = paste (unique(unique_id), collapse = ','))                                     

assign(paste0(DATAFRAME_USED,"_annotated"),a)
rm (a)
rm (df)
rm (df_withScaffold_info)
}

rm (lynxlynx_window_id)
rm (lynxpardinus_window_id)
rm (common_fields)

# Annotate df

c_ll_ki_n008_diversity_windows_auto <- full_join (c_ll_ki_n008_diversity_windows_auto, lynxlynx_window_id_annotated, by ="window_id")
c_ll_no_n008_diversity_windows_auto <- full_join (c_ll_no_n008_diversity_windows_auto, lynxlynx_window_id_annotated, by ="window_id")
c_ll_po_n008_diversity_windows_auto <- full_join (c_ll_po_n008_diversity_windows_auto, lynxlynx_window_id_annotated, by ="window_id")
c_lp_sm_n012_diversity_windows_auto <- full_join (c_lp_sm_n012_diversity_windows_auto, lynxpardinus_window_id_annotated, by ="window_id")
c_lp_do_n012_diversity_windows_auto <- full_join (c_lp_do_n012_diversity_windows_auto, lynxpardinus_window_id_annotated, by ="window_id")

c_ll_ki_n008_diversity_windows_X <- full_join (c_ll_ki_n008_diversity_windows_X, lynxlynx_window_id_annotated, by ="window_id")
c_ll_no_n008_diversity_windows_X <- full_join (c_ll_no_n008_diversity_windows_X, lynxlynx_window_id_annotated, by ="window_id")
c_ll_po_n008_diversity_windows_X <- full_join (c_ll_po_n008_diversity_windows_X, lynxlynx_window_id_annotated, by ="window_id")
c_lp_sm_n012_diversity_windows_X <- full_join (c_lp_sm_n012_diversity_windows_X, lynxpardinus_window_id_annotated, by ="window_id")
c_lp_do_n012_diversity_windows_X <- full_join (c_lp_do_n012_diversity_windows_X, lynxpardinus_window_id_annotated, by ="window_id")

```

http://ianmadd.github.io/pages/PeakDensityDistribution.html
## Density plot watterson
Now we are plotting a density plot of the diversity (watterson and pi) of the populations. Those are bimodal. Therefore I will get the lowest value of this density plot in order to stablish a threshold for "no diverse" vs "diverse" units. We will used this threshold for Tajima plot. 

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")

for (DATAFRAME_USED in DATAFRAMES) 
{

DATAFRAME <- get(DATAFRAME_USED) 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop=as.character(pop)) %>% .[1,1] 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
print (DATAFRAME_USED)
DATAFRAME$ave_pairwise <- as.numeric(DATAFRAME$ave_pairwise)
DATAFRAME$ave_watterson <- as.numeric(DATAFRAME$ave_watterson)









if (POP=="c_lp_sm_n012" || POP=="c_ll_no_n008" && TYPE_CHR=="Xchr")
{
maxY1_position <- which.max(density(log10(DATAFRAME$ave_watterson))$y)
maxX1_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_watterson))$y[density(log10(DATAFRAME$ave_watterson))$x<(maxX1_value-1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_watterson))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY2_position] 
Densitywatterson.Y <- density(log10(DATAFRAME$ave_watterson))$y
Densitywatterson.X <- density(log10(DATAFRAME$ave_watterson))$x
minY_value <- min(Densitywatterson.Y[Densitywatterson.X > maxX2_value & Densitywatterson.X < maxX1_value])
minY_position <- which(Densitywatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_watterson))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_watterson"), c(POP,minX_value))
} else  {
maxY1_position <- which.max(density(log10(DATAFRAME$ave_watterson))$y)
maxX1_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_watterson))$y[density(log10(DATAFRAME$ave_watterson))$x>(maxX1_value+1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_watterson))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY2_position] 
Densitywatterson.Y <- density(log10(DATAFRAME$ave_watterson))$y
Densitywatterson.X <- density(log10(DATAFRAME$ave_watterson))$x
minY_value <- min(Densitywatterson.Y[Densitywatterson.X < maxX2_value & Densitywatterson.X > maxX1_value])
minY_position <- which(Densitywatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_watterson))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_watterson"), c(POP,minX_value))
}

}
# Uno las distintas tablas de puntos de corte. 

density_min_values_watterson_auto <- as.data.frame(rbind (c_lp_sm_n012_auto_density_min_value_watterson, c_lp_do_n012_auto_density_min_value_watterson, c_ll_ki_n008_auto_density_min_value_watterson, c_ll_po_n008_auto_density_min_value_watterson, c_ll_no_n008_auto_density_min_value_watterson)) %>% mutate (type_chr="auto")
density_min_values_watterson_xchr <- as.data.frame(rbind (c_lp_sm_n012_Xchr_density_min_value_watterson, c_lp_do_n012_Xchr_density_min_value_watterson, c_ll_ki_n008_Xchr_density_min_value_watterson, c_ll_po_n008_Xchr_density_min_value_watterson, c_ll_no_n008_Xchr_density_min_value_watterson)) %>% mutate (type_chr="Xchr")

density_min_values_watterson <- as.data.frame(rbind(density_min_values_watterson_auto, density_min_values_watterson_xchr))

names(density_min_values_watterson) <- c("pop", "min_density_value_watterson", "type_chr")
density_min_values_watterson$min_density_value_watterson <- as.numeric(as.character(density_min_values_watterson$min_density_value_watterson))

rm (c_lp_sm_n012_auto_density_min_value_watterson)
rm (c_lp_sm_n012_Xchr_density_min_value_watterson)

rm (c_lp_do_n012_auto_density_min_value_watterson)
rm (c_lp_do_n012_Xchr_density_min_value_watterson)

rm (c_ll_ki_n008_auto_density_min_value_watterson)
rm (c_ll_ki_n008_Xchr_density_min_value_watterson)

rm (c_ll_po_n008_auto_density_min_value_watterson)
rm (c_ll_po_n008_Xchr_density_min_value_watterson)

rm (c_ll_no_n008_auto_density_min_value_watterson) 
rm (c_ll_no_n008_Xchr_density_min_value_watterson) 

rm (density_min_values_watterson_auto)
rm (density_min_values_watterson_xchr)
rm (DATAFRAME)
```

## Density plot pairwise

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
  
  
DATAFRAME <- get(DATAFRAME_USED) 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop=as.character(pop)) %>% .[1,1] 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
print (DATAFRAME_USED)

# Esto lo hago porque el pico más alto está en la deecha en este ejemplo concreto por eso tengo que buscar el mínimo a la iquierda de este pico x<(maxvalue -1) & tb esta modificado esto: minY_value <- min(Densitypairwise.Y[Densitypairwise.X > maxX2_value & Densitypairwise.X < maxX1_value])

if (POP=="c_lp_sm_n012" && TYPE_CHR=="auto" )
{
maxY1_position <- which.max(density(log10(DATAFRAME$ave_pairwise))$y)
maxX1_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_pairwise))$y[density(log10(DATAFRAME$ave_pairwise))$x<(maxX1_value-1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_pairwise))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$ave_pairwise))$y
Densitypairwise.X <- density(log10(DATAFRAME$ave_pairwise))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X > maxX2_value & Densitypairwise.X < maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_pairwise))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_pairwise"), c(POP,minX_value))

}else{

maxY1_position <- which.max(density(log10(DATAFRAME$ave_pairwise))$y)
maxX1_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_pairwise))$y[density(log10(DATAFRAME$ave_pairwise))$x>(maxX1_value+1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_pairwise))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$ave_pairwise))$y
Densitypairwise.X <- density(log10(DATAFRAME$ave_pairwise))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X < maxX2_value & Densitypairwise.X > maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_pairwise))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_pairwise"), c(POP,minX_value))
}
}

# Uno las distintas tablas de puntos de corte. 

density_min_values_pairwise_auto <- as.data.frame(rbind (c_lp_sm_n012_auto_density_min_value_pairwise, c_lp_do_n012_auto_density_min_value_pairwise, c_ll_ki_n008_auto_density_min_value_pairwise, c_ll_po_n008_auto_density_min_value_pairwise, c_ll_no_n008_auto_density_min_value_pairwise)) %>% mutate (type_chr="auto")
density_min_values_pairwise_xchr <- as.data.frame(rbind (c_lp_sm_n012_Xchr_density_min_value_pairwise, c_lp_do_n012_Xchr_density_min_value_pairwise, c_ll_ki_n008_Xchr_density_min_value_pairwise, c_ll_po_n008_Xchr_density_min_value_pairwise, c_ll_no_n008_Xchr_density_min_value_pairwise)) %>% mutate (type_chr="Xchr")

density_min_values_pairwise <- as.data.frame(rbind(density_min_values_pairwise_auto, density_min_values_pairwise_xchr))

names(density_min_values_pairwise) <- c("pop", "min_density_value_pairwise", "type_chr")
density_min_values_pairwise$min_density_value_pairwise <- as.numeric(as.character(density_min_values_pairwise$min_density_value_pairwise))

rm (c_lp_sm_n012_auto_density_min_value_pairwise)
rm (c_lp_sm_n012_Xchr_density_min_value_pairwise)

rm (c_lp_do_n012_auto_density_min_value_pairwise)
rm (c_lp_do_n012_Xchr_density_min_value_pairwise)

rm (c_ll_ki_n008_auto_density_min_value_pairwise)
rm (c_ll_ki_n008_Xchr_density_min_value_pairwise)

rm (c_ll_po_n008_auto_density_min_value_pairwise)
rm (c_ll_po_n008_Xchr_density_min_value_pairwise)

rm (c_ll_no_n008_auto_density_min_value_pairwise) 
rm (c_ll_no_n008_Xchr_density_min_value_pairwise) 

rm (density_min_values_pairwise_auto)
rm (density_min_values_pairwise_xchr)
rm (DATAFRAME)
```

## Create new variable low values to zero
Now I create a new variable replacing the diversity of units below the minimun of the density plot by 0; i.e. below the minimum value of the bimodal distributions, units are not variable, and hence, 0. 
```{r}

DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
DATAFRAME <- get(DATAFRAME_USED) 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 

if (TYPE_CHR=="auto"){
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="auto") 
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="auto") 

} else { 
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="Xchr")
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="Xchr") 

}
  
DATAFRAME_MODIF <- DATAFRAME %>% 
  dplyr::mutate (watterson_zero = ifelse (
pop=="c_lp_sm_n012"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_lp_sm_n012")$min_density_value_watterson) | 
pop=="c_lp_do_n012"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_lp_do_n012")$min_density_value_watterson) | 
pop=="c_ll_ki_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_ki_n008")$min_density_value_watterson) | 
pop=="c_ll_po_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_po_n008")$min_density_value_watterson) | 
pop=="c_ll_no_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_no_n008")$min_density_value_watterson),0,ave_watterson)) %>% 
  dplyr::mutate (pairwise_zero = ifelse (pop=="c_lp_sm_n012"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_lp_sm_n012")$min_density_value_pairwise) | 
pop=="c_lp_do_n012"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_lp_do_n012")$min_density_value_pairwise) | 
pop=="c_ll_ki_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_ki_n008")$min_density_value_pairwise) | 
pop=="c_ll_po_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_po_n008")$min_density_value_pairwise) | 
pop=="c_ll_no_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_no_n008")$min_density_value_pairwise),0,ave_pairwise)) %>%
  dplyr::mutate(tajimaD_transformed = ifelse(watterson_zero!="0" | pairwise_zero!="0", tajimaD, NA)) %>% select (-tajimaD) %>%  dplyr::rename(.,"tajimaD"="tajimaD_transformed")
assign(paste0(DATAFRAME_USED), DATAFRAME_MODIF , envir = globalenv() )

}
```

### *Plot diversity

```{r}

DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
DATAFRAME <- get(DATAFRAME_USED) 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop.x=as.character(pop)) %>% .[1,1] 

#if (TYPE_CHR=="auto"){
#  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="auto") 
#  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="auto") 
#} else { 
#  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="Xchr")
#  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="Xchr") 
#}
  
# Pairwise:
#min_pop_value_pairwise <- as.numeric(density_min_values_pairwise_filtered %>% dplyr::filter(pop==POP) %>% .[1,2] )
#min_pop_value_watterson <- as.numeric(density_min_values_watterson_filtered %>% dplyr::filter(pop==POP) %>% .[1,2] )

ggplot (DATAFRAME , aes(log10(ave_pairwise)))+
  geom_density()+
 # geom_vline(xintercept= min_pop_value_pairwise, color='grey20') +
  ggsave (paste0(wd_output, POP, "_", TYPE_CHR, "_pairwise_density.pdf"))


ggplot (DATAFRAME , aes(log10(ave_watterson)))+
  geom_density()+
 # geom_vline(xintercept= min_pop_value_watterson, color='grey20') +
ggsave (paste0(wd_output, POP, "_", TYPE_CHR, "_watterson_density.pdf"))

#

}

```

# Create comparison dataframe.

```{r}
create_data_diversity_bootleneck_vs_non_bootleneck <- function(POP1, POP2, name_POP1, name_POP2){
POPULATION1=POP1 %>% select(pop) %>% mutate(Populations=as.character(pop)) %>% .[1,1] 
POPULATION2=POP2 %>% select(pop) %>% mutate(Populations=as.character(pop)) %>% .[1,1] 
  data_diversity_POP1_POP2 <- dplyr::inner_join (POP1, POP2, by = c("window_id", "feature", "type_chr", "window", "scaffold_pos1_pos2","divergence_weighted", "recombination_weighted", "GC_content_weighted", "rvis_score_weighted", "centr_percentage_weighted", "tel10m_percentage_weighted", "tel2m_percentage_weighted", "region_collapse", "chr_collapse", "unique_id_collapse")) %>%  
  # Calculo el delta 
dplyr::mutate (delta_pairwise = (as.numeric(ave_pairwise.y) - as.numeric(ave_pairwise.x))) %>%
dplyr::mutate (delta_watterson = (as.numeric(ave_watterson.y) - as.numeric(ave_watterson.x))) %>% 
dplyr::mutate (delta_pairwise_corrected = (as.numeric(ave_pairwise.y) - as.numeric(ave_pairwise.x))/(as.numeric(ave_pairwise.y) + as.numeric(ave_pairwise.x))) %>% 
dplyr::mutate (delta_watterson_corrected = ((as.numeric(ave_watterson.y) - as.numeric(ave_watterson.x))/(as.numeric(ave_watterson.y) + as.numeric(ave_watterson.x)))) %>% 
   # dplyr::mutate (delta_tajimaD=(as.numeric(tajimaD.y)-as.numeric(tajimaD.x))) %>% 
dplyr::mutate (delta_w_delta_p=delta_watterson_corrected-delta_pairwise_corrected) %>% 
dplyr::mutate (ratio_pi=(as.numeric(ave_pairwise.y) / as.numeric(ave_pairwise.x))) %>% 
dplyr::mutate (ratio_watterson=(as.numeric(ave_watterson.y) / as.numeric(ave_watterson.x))) %>% 
   # Add comparison title  
dplyr::mutate(comparison=paste(POPULATION1, "-", POPULATION2, sep=""))
  dataframename <- paste (name_POP1, name_POP2, sep="_")
  assign (dataframename, data_diversity_POP1_POP2,.GlobalEnv)
}

# Autosomes
# Create data frame
# Dataframe Kirov-Norway
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_auto,c_ll_no_n008_diversity_windows_auto, deparse(substitute(c_ll_ki_n008_diversity_windows_auto)),deparse(substitute(c_ll_no_n008_diversity_windows_auto)))
# Dataframe Kirov-Poland
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_auto,c_ll_po_n008_diversity_windows_auto, deparse(substitute(c_ll_ki_n008_diversity_windows_auto)),deparse(substitute(c_ll_po_n008_diversity_windows_auto)))
# Dataframe Sierra_Morena-Doñana
create_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n012_diversity_windows_auto,c_lp_do_n012_diversity_windows_auto, deparse(substitute(c_lp_sm_n012_diversity_windows_auto)),deparse(substitute(c_lp_do_n012_diversity_windows_auto)))


## X chr
# Dataframe Kirov-Norway
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_X,c_ll_no_n008_diversity_windows_X, deparse(substitute(c_ll_ki_n008_diversity_windows_X)),deparse(substitute(c_ll_no_n008_diversity_windows_X)))
# Dataframe Kirov-Poland
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_X,c_ll_po_n008_diversity_windows_X, deparse(substitute(c_ll_ki_n008_diversity_windows_X)),deparse(substitute(c_ll_po_n008_diversity_windows_X)))
# Dataframe Sierra_Morena-Doñana
create_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n012_diversity_windows_X,c_lp_do_n012_diversity_windows_X, deparse(substitute(c_lp_sm_n012_diversity_windows_X)),deparse(substitute(c_lp_do_n012_diversity_windows_X)))

# Combine comparisons
#all_comparisons_diversity_bootleneck_vs_non_bootleneck_window <- rbind (c_ll_ki_n008_diversity_windows_c_ll_no_n008_diversity_windows, c_ll_ki_n008_diversity_windows_c_ll_po_n008_diversity_windows, c_lp_sm_n012_diversity_windows_c_lp_do_n012_diversity_windows)

```



# Cuadrantes


```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")

for (DATAFRAME in DATAFRAMES) 
{
 
# Pairwise:
# min_pop_value_pairwise_NB <- as.numeric(density_min_values_pairwise_filtered %>% dplyr::filter(pop=="c_ll_ki_n008" ) %>% .[1,2] )
# min_pop_value_pairwise_B <- as.numeric(density_min_values_watterson_filtered %>% dplyr::filter(pop=="c_ll_no_n008") %>% .[1,2] )
# 
#  data_diversity_categories_pairwise <- get(DATAFRAME) %>% 
#   mutate (evolution_category=
# ifelse (log10(ave_pairwise.x)>min_pop_value_pairwise_NB & log10(ave_pairwise.y)>min_pop_value_pairwise_B, "D_D_pairwise",
# ifelse (log10(ave_pairwise.x)>min_pop_value_pairwise_NB & log10(ave_pairwise.y)<min_pop_value_pairwise_B, "D_ND_pairwise",
# ifelse (log10(ave_pairwise.x)<min_pop_value_pairwise_NB & log10(ave_pairwise.y)<min_pop_value_pairwise_B, "ND_ND_pairwise",
# ifelse (log10(ave_pairwise.x)<min_pop_value_pairwise_NB & log10(ave_pairwise.y)>min_pop_value_pairwise_B, "ND_D_pairwise",NA))))) %>% 
#   mutate (diversity_category=
# ifelse (log10(ave_pairwise.x)>min_pop_value_pairwise_NB, "HD_pairwise",
# ifelse (log10(ave_pairwise.x)<min_pop_value_pairwise_NB, "LD_pairwise",NA)))
# 
# data_diversity_categories_pairwise$evolution_category <- factor (data_diversity_categories_pairwise$evolution_category, levels=c("D_ND_pairwise", "D_D_pairwise", "ND_ND_pairwise", "ND_D_pairwise"))
# data_diversity_categories_pairwise$diversity_category <- factor (data_diversity_categories_pairwise$diversity_category, levels=c("HD_pairwise", "LD_pairwise"))

#, colour=evolution_category
ggplot(get(DATAFRAME) %>% filter (feature=="CDS" | feature=="intergenic" | feature=="intron") , aes(x=log10(ave_watterson.x) ,y=log10(ave_watterson.y))) +
geom_point(alpha = 1/100) +
geom_abline(intercept = 0, color='grey20') +
#geom_hline(yintercept= min_pop_value_pairwise_B, color='grey20') +
#geom_vline(xintercept = min_pop_value_pairwise_NB, color='grey20') +
facet_wrap(~feature) +
ggsave (paste(wd_output,DATAFRAME,"_CUADRANTES_WA.pdf", sep=""), width = 25, height = 25, units = "cm")


ggplot(get(DATAFRAME) %>% filter (feature=="CDS" | feature=="intergenic" | feature=="intron"), aes(x=log10(ave_pairwise.x) ,y=log10(ave_pairwise.y))) +
geom_point(alpha = 1/100) +
geom_abline(intercept = 0, color='grey20') +
#geom_hline(yintercept= min_pop_value_pairwise_B, color='grey20') +
#geom_vline(xintercept = min_pop_value_pairwise_NB, color='grey20') +
facet_wrap(~feature, ) +
ggsave (paste(wd_output,DATAFRAME,"_CUADRANTES_PI.pdf", sep=""), width = 25, height = 25, units = "cm")

}

 # summary1 <- data_diversity_categories_pairwise %>% 
 #   group_by(feature) %>% 
 #   summarise(total=n()) 
 # 
 # 
 # summary <- data_diversity_categories_pairwise %>% 
 #   group_by(evolution_category, feature) %>% 
 #   summarise(counts_windows=n()) %>% 
 #   full_join(summary1) %>% 
 #   mutate (proportion=counts_windows/total*100)
 # 
 

```


## *Delta distribution
```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")


for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
 # Watterson
   # Plot de la distribución de delta corregida
  ggplot(get(DATAFRAME), aes(x=(delta_watterson_corrected))) + 
geom_histogram() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_watterson_corrected_average_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
aes(x = delta_watterson_corrected) +
geom_histogram() +
facet_wrap(~feature, scales = "free")  +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_watterson_corrected_average_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

 # Plot de la distribución de ratio para cada feature
  ggplot(get(DATAFRAME)) + 
aes(x = ratio_watterson) +
geom_histogram() +
facet_wrap(~feature, scales = "free")  +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
ggsave (paste(wd_output,DATAFRAME,"_ratio_watterson_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

 
 # PI
  # Plot de la distribución de delta corregida
 ggplot(get(DATAFRAME), aes(x=(delta_pairwise_corrected))) + 
geom_histogram() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_pairwise_corrected_average_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
aes(x = delta_pairwise_corrected) +
geom_histogram() +
facet_wrap(~feature, scales = "free")  +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_pairwise_corrected_average_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

# Plot de la distribución de ratio para cada feature

 ggplot(get(DATAFRAME)) + 
aes(x = ratio_pi) +
geom_histogram() +
facet_wrap(~feature, scales = "free")  +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
ggsave (paste(wd_output,DATAFRAME,"_ratio_pairwise_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

  
 # Delta delta
 
  ggplot(get(DATAFRAME), aes(x=(delta_w_delta_p))) + 
geom_histogram() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_D_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
aes(x = delta_w_delta_p) +
geom_histogram() +
facet_wrap(~feature, scales = "free")  +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
ggsave (paste(wd_output,DATAFRAME,"_delta_D_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

}

```

## *Test for normality of D

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto")

for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
Shapiro_results <- get(DATAFRAME) %>%
  dplyr::group_by(feature) %>%
  dplyr::sample_n(200) %>% 
  summarise(statistic = shapiro.test(delta_w_delta_p)$statistic,
p.value = shapiro.test(delta_w_delta_p)$p.value) %>% as.data.frame()

write.table(format(Shapiro_results, digits=8, scientific=T), paste(wd_output,DATAFRAME,"_shapiro_test.txt",sep=""), row.names = F)
}


```
Como la mayoría son no normales hacemos test de U-Mann Whitney.

## U-Mann Whitney
```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto")

for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
wilcox_test_df <- pairwise.wilcox.test(get(DATAFRAME)$delta_w_delta_p, get(DATAFRAME)$feature, p.adjust.method = "bonferroni") 

wilcox_test_df_reshape <-melt(wilcox_test_df[[3]]) %>% 
  filter (!is.na(value)) %>% 
  mutate (SIG=ifelse(value<0.05, "SIGN", "no")) %>% 
  mutate (comparison = paste0(POP1,"_", POP2)) %>% 
  mutate (method = "wilcox.test") %>% 
  mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008_c_ll_po_n008", "Kirov_Poland",
  ifelse (comparison == "c_ll_ki_n008_c_ll_no_n008", "Kirov_Norway",
  ifelse (comparison == "c_lp_sm_n012_c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison)

write.table(format(wilcox_test_df_reshape, digits=8, scientific=T), paste(wd_output,DATAFRAME,"_wilcox_test.txt",sep=""), row.names = F, quote=F)

}

```

En mi local hago lo siguiente:

```{bash}
cat /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto_wilcox_test.txt <(tail -n +2 /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto_wilcox_test.txt ) <(tail -n +2 /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto_wilcox_test.txt )  > /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/all_popx_windows_delta_D_distribution_auto_wilcox_test.txt
```



## *Sanity: Delta vs initial diversity

```{r}
ggplot (c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto, aes(x = log10(ave_watterson.x), y = delta_watterson_corrected))+
  geom_point() +
  geom_smooth()

ggplot (c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto, aes(x = log10(ave_pairwise.x), y = delta_pairwise_corrected))+
  geom_point() +
  geom_smooth ()

```

## *Delta watterson and delta pi per pop and feature.

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")

DELTA_MEASURES=c("delta_pairwise","delta_watterson", "delta_watterson_corrected", "delta_pairwise_corrected", "ratio_watterson", "ratio_pi")


scale_x_discrete2 <- function(..., expand = waiver(), position = "bottom") {
  sc <- discrete_scale(c("x", "xmin", "xmax", "xend"), "position_d", identity, ..., expand = expand, guide = "none", position = position, super = ScaleDiscretePositionFunc)
  sc$range_c <- ggplot2:::continuous_range()
  sc
}


for (DATAFRAME in DATAFRAMES) 
{
  for (DELTA_MEASURE in DELTA_MEASURES)
  {
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  type_chr=get(DATAFRAME) %>% select(type_chr) %>% .[1,1] 

  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
ggplot(get(DATAFRAME), aes_string(x="feature", y=DELTA_MEASURE))+
  stat_summary(fun.data = "mean_cl_boot", size = 0.1) +
  coord_flip() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#  scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
#  scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  # PONER EL VALOR DEL GENERAL (ralla?)
#scale_fill_viridis_d(option = "magma")+
#scale_colour_viridis_d(option = "magma")+
#scale_x_discrete2(limits = rev)+

ggsave (paste(wd_output,POP1, "_", POP2, "_", DELTA_MEASURE,"_", type_chr, ".pdf", sep=""), width = 80, height = 80, units = "mm")
}
}

```

# *Delta_D per pop and feature. 

```{r}
# AUTOSOMES
comparison_pops_auto <- rbind (c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto, c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto, c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto) %>% 
   mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008-c_ll_po_n008", "Kirov_Poland",
  ifelse (comparison == "c_ll_ki_n008-c_ll_no_n008", "Kirov_Norway",
  ifelse (comparison == "c_lp_sm_n012-c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison) %>% 
  mutate(comparison=pop1_pop2) %>% 
  select (-pop1_pop2)

comparison_pops_auto$feature <- plyr::revalue(comparison_pops_auto$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))
comparison_pops_auto$feature <- factor (comparison_pops_auto$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

comparison_pops_auto$comparison <- factor (comparison_pops_auto$comparison, levels=c("Kirov_Poland", "Kirov_Norway", "Andujar_Donana"))

comparison_pops_auto_summary <- comparison_pops_auto %>% 
 dplyr::group_by(feature, comparison) %>%
 dplyr::summarise(
   mean_delta_watterson=mean(delta_watterson_corrected, na.rm = TRUE),
   se_mean_delta_watterson = sd(boot(delta_watterson_corrected, sample.wtd.mean, R = 100)$t),
   mean_delta_pairwise=mean(delta_pairwise_corrected, na.rm = TRUE),
   se_mean_delta_pairwise = sd(boot(delta_pairwise_corrected, sample.wtd.mean, R = 100)$t))

ggplot(data=comparison_pops_auto_summary, aes(mean_delta_pairwise, mean_delta_watterson)) +
  geom_point(aes(colour=feature, fill=feature))+
  scale_fill_viridis_d(option = "plasma")+
  scale_colour_viridis_d(option = "plasma")+
  geom_abline (colour="grey", linetype = "dashed") +
  geom_errorbar(aes(ymin=mean_delta_watterson-se_mean_delta_watterson, ymax=mean_delta_watterson+se_mean_delta_watterson, colour=feature, fill=feature)) +
  geom_errorbarh(aes(xmin = mean_delta_pairwise - se_mean_delta_pairwise, xmax = mean_delta_pairwise + se_mean_delta_pairwise, colour=feature, fill=feature)) +
  facet_wrap(~comparison)+
  geom_text_repel(aes(label = feature),
  box.padding   = 1, 
  point.padding = 0.1,
  size  = 2.5,
  force = 80,
  segment.size  = 0.2,
  segment.color = 'grey50') +
  theme(legend.position = "none") +
  ggsave (paste(wd_output,"delta_pi_vs_delta_watterson_auto.pdf", sep=""), width = 160, height = 80, units = "mm")

ggplot(comparison_pops_auto, aes(x=feature, y=delta_w_delta_p, colour=comparison, fill=comparison, shape=comparison))+
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
  stat_summary(fun.y = mean,
   geom = "line")+
  coord_flip() +
  facet_wrap (~comparison) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")+
  scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
ggsave (paste(wd_output,"delta_delta_all_pops_auto_separated.pdf", sep=""), width = 160, height = 80, units = "mm")

# Xchr
comparison_pops_Xchr <- rbind (c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X, c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X, c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X) %>% 
   mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008-c_ll_po_n008", "Kirov_Poland",
  ifelse (comparison == "c_ll_ki_n008-c_ll_no_n008", "Kirov_Norway",
  ifelse (comparison == "c_lp_sm_n012-c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison) %>% 
  mutate(comparison=pop1_pop2) %>% 
  select (-pop1_pop2) %>% 
  filter (feature!="UCNE") # Los quito porque solo hay dos valores y no es fiable. 

comparison_pops_Xchr$feature <- plyr::revalue(comparison_pops_Xchr$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA"))
comparison_pops_Xchr$feature <- factor (comparison_pops_Xchr$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA"))

comparison_pops_Xchr$comparison <- factor (comparison_pops_Xchr$comparison, levels=c("Kirov_Poland", "Kirov_Norway", "Andujar_Donana"))



comparison_pops_Xchr_summary <- comparison_pops_Xchr %>% 
 dplyr::group_by(feature, comparison) %>%
 dplyr::summarise(
   mean_delta_watterson=mean(delta_watterson_corrected, na.rm = TRUE),
   se_mean_delta_watterson = sd(boot(delta_watterson_corrected, sample.wtd.mean, R = 100)$t),
   mean_delta_pairwise=mean(delta_pairwise_corrected, na.rm = TRUE),
   se_mean_delta_pairwise = sd(boot(delta_pairwise_corrected, sample.wtd.mean, R = 100)$t))

ggplot(data=comparison_pops_Xchr_summary, aes(mean_delta_pairwise, mean_delta_watterson)) +
  geom_point(aes(colour=feature, fill=feature))+
  scale_fill_viridis_d(option = "plasma")+
  scale_colour_viridis_d(option = "plasma")+
  geom_abline (colour="grey", linetype = "dashed") +
  geom_errorbar(aes(ymin=mean_delta_watterson-se_mean_delta_watterson, ymax=mean_delta_watterson+se_mean_delta_watterson, colour=feature, fill=feature)) +
  geom_errorbarh(aes(xmin = mean_delta_pairwise - se_mean_delta_pairwise, xmax = mean_delta_pairwise + se_mean_delta_pairwise, colour=feature, fill=feature)) +
  facet_wrap(~comparison)+
  geom_text_repel(aes(label = feature),
  box.padding   = 1, 
  point.padding = 0.1,
  size  = 2.5,
  force = 80,
  segment.size  = 0.2,
  segment.color = 'grey50') +
  theme(legend.position = "none") +
  ggsave (paste(wd_output,"delta_pi_vs_delta_watterson_Xchr.pdf", sep=""), width = 160, height = 80, units = "mm")



ggplot(comparison_pops_Xchr, aes(x=feature, y=delta_w_delta_p, colour=comparison, fill=comparison, shape=comparison))+
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
  stat_summary(fun.y = mean,
   geom = "line")+
  coord_flip() +
  facet_wrap (~comparison) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")+
  scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
ggsave (paste(wd_output,"delta_delta_all_pops_Xchr.pdf", sep=""), width = 160, height = 80, units = "mm")
```

