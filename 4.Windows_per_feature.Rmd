---
title: "4.Windows_per_feature"
output: html_document
---

Test to see whether we could concatenate all the features and run a window approach over it.


# 1. Get position for every feature:

```{bash}

mkdir /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/

POP=c_lp_do_n012 # <--- Change pop here!
screen -S "$POP"_get_feature_coordinates
POP=c_lp_do_n012 # <--- Change pop here!
script log_screen_"$POP"_get_feature_coordinates.log
POP=c_lp_do_n012 # <--- Change pop here!

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs

## Variables
SCAFFOLDS_FOLDER=/GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3.PerScaffold/
FEATURE_POSITIONS_FOLDER=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/
SFS_FOLDER=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/
FEATURE="CDS"
OUTPUT_DIR=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature
REF="/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated"

#FEATURES=(UCNE intergenic 3UTR 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)
FEATURES=(5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

echo "---------------------------------------------------$POP---------------------------------------------------"

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
for iteration in {1..10}
do
rm "${OUTPUT_DIR}"/"${POP}".transformedThetas_iteration"$iteration"."${FEATURE}"
SCAFFOLD_START=$( echo '1 + 4170 * ('$iteration' - 1)' | bc)
SCAFFOLD_END=$( echo '4170 * '$iteration | bc )
for SCAFFOLD_NUMBER in $(seq -s " " -f %05g $SCAFFOLD_START $SCAFFOLD_END) # esta manera de hacer seq te va a sacar siempre 5 cifras.
do
SCAFFOLD=$(echo "lp23.s"$SCAFFOLD_NUMBER)
cd "$SFS_FOLDER""$POP"_separated_by_scaffold
cat "$POP".transformedThetas_"$SCAFFOLD" | bedtools intersect -a stdin -b <( cat "$SCAFFOLDS_FOLDER"LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3_"$SCAFFOLD" | grep $FEATURE) -sorted -g $REF | awk -v OFS='\t' '{print $1, $2, $3, $4, $5}' >> "${OUTPUT_DIR}"/"${POP}".transformedThetas_iteration"$iteration"."${FEATURE}"
done &
done 
done

```

# 2. Get common positions among pops

We are using the intermediate interaction files to avoid large files.

## Bedtools approach

```{bash}

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

REF="/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated"
OUTPUT_DIR=/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature
FEATURES=(5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

#3UTR intergenic UCNE

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
for iteration in {1..10}
do
echo $iteration
echo "doing lynx pardinus"
bedtools intersect -a <(cat c_lp_sm_n012.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}') -b <(cat c_lp_do_n012.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}') -sorted -g $REF > c_lp_iteration"$iteration"."${FEATURE}".innercoordinates

# Filter do for the coordinates in common.
#bedtools intersect -a  <(cat "${OUTPUT_DIR}"/c_lp_do_n012.transformedThetas_iteration"$iteration"."${FEATURE}") -b <(cat c_lp_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_lp_do_n012.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter sm for the coordinates in common.
bedtools intersect -a  <(cat "${OUTPUT_DIR}"/c_lp_sm_n012.transformedThetas_iteration"$iteration"."${FEATURE}") -b <(cat c_lp_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_lp_sm_n012.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

#echo "doing lynx lynx"

## LYNX LYNX ## ## ## ## ## 
# I am doing a inner join:
# I am doing it in 3 different steps althougth I would need it, because, when I get to ll I will need to do it like that, or it will be more complex.
# 1. Get coordinates in common for the three pop.
#bedtools intersect -a <(cat c_ll_ki_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}') -b <(cat c_ll_po_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}') -sorted -g $REF | bedtools intersect -a - -b <(cat c_ll_no_n008.transformedThetas_iteration"$iteration"."${FEATURE}" |  awk -v OFS='\t' '{print $1, $2, $3}') -sorted -g $REF> c_ll_iteration"$iteration"."${FEATURE}".innercoordinates

# Filter ki for the coordinates in common.
#bedtools intersect -a  <(cat "${OUTPUT_DIR}"/c_ll_ki_n008.transformedThetas_iteration"$iteration"."${FEATURE}") -b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_ki_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter no for the coordinates in common.
#bedtools intersect -a  <(cat "${OUTPUT_DIR}"/c_ll_no_n008.transformedThetas_iteration"$iteration"."${FEATURE}") -b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_no_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"

# Filter po for the coordinates in common.
#bedtools intersect -a  <(cat "${OUTPUT_DIR}"/c_ll_po_n008.transformedThetas_iteration"$iteration"."${FEATURE}") -b <(cat c_ll_iteration"$iteration"."${FEATURE}".innercoordinates) -sorted -g $REF > "${OUTPUT_DIR}"/c_ll_po_n008.transformedThetas_iteration"$iteration".filtered."${FEATURE}"
done
done

wc -l c_lp*iteration*
wc -l c_ll*iteration*

# Para pardinus tiene buena pinta!
rm c_lp_iteration*.innercoordinates



FEATURES=(UCNE 3UTR intergenic 5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)

for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
rm c_ll_ki_n008.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_ll_po_n008.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_ll_no_n008.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_lp_sm_n012.transformedThetas_iteration{1..10}."${FEATURE}"
rm c_lp_do_n012.transformedThetas_iteration{1..10}."${FEATURE}"
done


```

## X and autosomes file

I have to create a filter to filter for with the scaffolds associated to X chr and the scaffold associated with autosomes. 
```{bash}
cd /GRUPOS/grupolince/copia_fabascal/MAPPINGS/

awk '{print $1}' lynx2cat_wTiger_Xchr.sorted.merged.bed | sort | uniq > scaffold_Xchr_putatively
wc -l scaffold_Xchr_putatively
#1891 scaffold_X
# Those would be the scaffolds associated to Xchr, however! some of those are also present in autosomes, so I should filter them. 
grep -f scaffold_Xchr_putatively lynx2cat_wTiger_AUTOSOMALchr.sorted.merged.corrected.bed | awk '{print $1}' | sort | uniq > scaffold_X_Autosomes
wc -l scaffold_X_Autosomes
#250 scaffold_X_Autosomes

grep -v -f scaffold_X_Autosomes scaffold_Xchr > scaffold_Xchr_exclusively
wc -l scaffold_Xchr_exclusively
#1641 scaffold_Xchr_exclusively

# He guardado un README con esta info en la capeta. 

rm scaffold_X_Autosomes
# Vamos a usar el scaffold_Xchr_putatively para quitarnos todo lo que pudiera ser X del analisis de autosomico y scaffold_Xchr_exclusively para hacer el análisis de los X. 

# As I will use them with bedtools intersect, I need to add some coordinates. To do so I will grep those scaffold in lp23.lenght file and add the complete chr.

grep -f /GRUPOS/grupolince/copia_fabascal/MAPPINGS/scaffold_Xchr_exclusively /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated > /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr


grep -v -f /GRUPOS/grupolince/copia_fabascal/MAPPINGS/scaffold_Xchr_putatively /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated > /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes


```

As I thought about this filter after doing already some features, I have to different approaches right now. 

1. Filter the scaffolds before cat (intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000 3UTR UCNE 5UTR intergenic CDS).
2. Filter the scaffolds already in the transformed filtered file (3UTR UCNE 5UTR intergenic CDS intron).

What I am doing is:

Using the scaffold only assing to X chr to get X coordinates. However! I will use scaffold assinged to X OR X&Autosomes to filter all the scaffold. 
i.e.

X= scaffolds Assing only to X 
Autosomes= All scaffolds - (scaffold assigned to x OR to x & autosomes).

Los archivos son:

/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr
/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes

# Join all filtered iteractions and assign consecutive coordinates to a file

```{bash}

cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

#POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 c_lp_do_n012 c_lp_sm_n012)

#FEATURES=(intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000 )
REF=/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated
FEATURES=(5UTR intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000)
POPS=(c_lp_sm_n012)


for FEATURE in "${FEATURES[@]}"
do
for POP in "${POPS[@]}"
do

rm "$POP".transformedThetas.filtered.Xchr."${FEATURE}"
rm "$POP".transformedThetas.filtered.Auto."${FEATURE}"

# join all files
for iteration in {1..10}
do

echo "Doing "$FEATURE $POP $iteration 

bedtools intersect -a "$POP".transformedThetas_iteration$iteration.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr) -sorted -g $REF > "$POP".transformedThetas_iteration$iteration.filtered.Xchr."${FEATURE}"

bedtools intersect -a "$POP".transformedThetas_iteration$iteration.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes) -sorted -g $REF > "$POP".transformedThetas_iteration$iteration.filtered.Auto."${FEATURE}"

done
echo "finish filtering, ready to cat"
rm "$POP".transformedThetas_iteration{1..10}.filtered."${FEATURE}"

cat "$POP".transformedThetas_iteration{1..10}.filtered.Xchr."${FEATURE}" >> "$POP".transformedThetas.filtered.Xchr."${FEATURE}"
cat "$POP".transformedThetas_iteration{1..10}.filtered.Auto."${FEATURE}" >> "$POP".transformedThetas.filtered.Auto."${FEATURE}"

rm "$POP".transformedThetas_iteration{1..10}.filtered.Xchr."${FEATURE}"
rm "$POP".transformedThetas_iteration{1..10}.filtered.Auto."${FEATURE}"

echo "finish cat, ready to CONCAT"

# assign consecutive coordinates
awk -v OFS='\t' '{print "CONCATENATION", NR, NR+1, $4, $5, $6, $7, $8, $9}' "$POP".transformedThetas.filtered.Xchr."${FEATURE}" > "$POP".transformedThetas.filtered.CONCATENATION.Xchr."${FEATURE}" 

awk -v OFS='\t' '{print "CONCATENATION", NR, NR+1, $4, $5, $6, $7, $8, $9}' "$POP".transformedThetas.filtered.Auto."${FEATURE}" > "$POP".transformedThetas.filtered.CONCATENATION.Auto."${FEATURE}" 

echo "Done with" $POP "and" $FEATURE

done
done

wc -l *CONCATENATION*
```

# Filtering the already done FEATURES


```{bash}
cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 c_lp_do_n012 c_lp_sm_n012)

FEATURES=(3UTR UCNE 5UTR intergenic CDS intron) 

REF=/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated


FEATURES=(intron)

for FEATURE in "${FEATURES[@]}"
do
for POP in "${POPS[@]}"
do

echo $POP $FEATURE "doing intersect Xchr"
bedtools intersect -a "$POP".transformedThetas.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_Xchr) -sorted -g $REF > "$POP".transformedThetas.filtered.Xchr."${FEATURE}"
echo $POP $FEATURE "doing concat Xchr"
# assign consecutive coordinates
awk -v OFS='\t' '{print "CONCATENATION", NR, NR+1, $4, $5, $6, $7, $8, $9}' "$POP".transformedThetas.filtered.Xchr."${FEATURE}" > "$POP".transformedThetas.filtered.CONCATENATION.Xchr."${FEATURE}" 

#gzip "$POP".transformedThetas.filtered.Xchr."${FEATURE}"

#######
echo $POP $FEATURE "doing intersect AUTOSOMES"
echo "Autosomes"
bedtools intersect -a "$POP".transformedThetas.filtered."${FEATURE}" -b <(awk -v OFS="\t" '{print $1, "1", $2}' /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23_tab_separated_autosomes) -sorted -g $REF > "$POP".transformedThetas.filtered.Auto."${FEATURE}"
echo $POP $FEATURE "doing concat AUTOSOMES"

awk -v OFS='\t' '{print "CONCATENATION", NR, NR+1, $4, $5, $6, $7, $8, $9}' "$POP".transformedThetas.filtered.Auto."${FEATURE}" > "$POP".transformedThetas.filtered.CONCATENATION.Auto."${FEATURE}" 

#gzip "$POP".transformedThetas.filtered.Auto."${FEATURE}"

done
done

# BORRAR!
rm filtered."${FEATURE}"

```


# Compress files

Se ha quedado sin espacio asi que comprimo los archivos

```{bash}

for file in *filtered.Xchr.*
do
echo $file
gzip $file
done

for file in *filtered.Auto.*
do
echo $file
gzip $file
done

du -hc  *.Xchr.*gzip 
# 7 G

mkdir /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis

for file in *.Xchr.*gz 
do
echo $file
mv $file /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
done

#lanzado!
mv c_ll_ki_n008.transformedThetas.filtered.Auto.3UTR.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008.transformedThetas.filtered.Auto.5UTR.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008.transformedThetas.filtered.Auto.CDS.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008.transformedThetas.filtered.Auto.intergenic.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008.transformedThetas.filtered.Auto.intron.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008.transformedThetas.filtered.Auto.intron_lncRNA.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_lp_sm_n012.transformedThetas.filtered.Auto.intron.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv c_ll_ki_n008*gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
mv  c_ll_no_n008.transformedThetas.filtered.Auto.intron.gz /backup/mlucena/intermediate_files_ANGSD/whole_genome_analysis/window_analysis/
```

# Calculate diversity per windows.

Over the files I will performe window summary using this awk script I found online (and tested that it worked). 
window=50000
slide=10000

Esto lo he hecho con un archivo concatenado pero realmente no lo necestio. 
```{bash}

# 03/03/2020
# Como he detectado un error en Tajima D de los archivos submuestreados (explicado en 2.SFS_contemporary),  no voy a usar este valor para calcular mi tajima sino que lo voy a volver a calcular yo. 

POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 c_lp_do_n012 c_lp_sm_n012)
FEATURES=(intergenic CDS intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000 UCNE 3UTR 5UTR)

for POP in "${POPS[@]}"
do 

for FEATURE in "${FEATURES[@]}"
do
echo $POP $FEATURE "autosome"
awk -v OFS="\t" '{print $4,$5,$5-$4,($5-$4)^2}' $POP.transformedThetas.filtered.CONCATENATION.Auto.$FEATURE |  
awk -v OFS="\t" 'BEGIN{window=10000;slide=5000}  
{
mod=NR%window; if(NR<=window){count++}
else
{sum1-=array1[mod]; sum2-=array2[mod]; sum3-=array3[mod]; sumsq4-=array4[mod]}
sum1+=$1;
sum2+=$2;
sum3+=$3;
sumsq4+=$4
array1[mod]=$1;
array2[mod]=$2;
array3[mod]=$3;
array4[mod]=$4
} 
(NR%slide)==0{print NR, sum1/count, sum2/count, sqrt((sumsq4-((sum3^2)/count))/count)}'  | awk -v OFS="\t" '{ if(NR==1) print "coord_end","ave_watterson","ave_pairwise", "tajimaD"} {print $1, $2, $3, ($3-$2)/$4}' | \
sed -e '2d' > $POP.transformedThetas.filtered.windows.auto.$FEATURE 

echo $POP $FEATURE "Xchr"

awk -v OFS="\t" '{print $4,$5,$5-$4,($5-$4)^2}' <(cat $POP.transformedThetas.filtered.CONCATENATION.Xchr.$FEATURE) |  
awk -v OFS="\t" 'BEGIN{window=10000;slide=5000}  
{
mod=NR%window; if(NR<=window){count++}
else
{sum1-=array1[mod]; sum2-=array2[mod]; sum3-=array3[mod]; sumsq4-=array4[mod]}
sum1+=$1;
sum2+=$2;
sum3+=$3;
sumsq4+=$4
array1[mod]=$1;
array2[mod]=$2;
array3[mod]=$3;
array4[mod]=$4
} 
(NR%slide)==0{print NR, sum1/count, sum2/count, sqrt((sumsq4-((sum3^2)/count))/count)}'  | awk -v OFS="\t" '{ if(NR==1) print "coord_end","ave_watterson","ave_pairwise", "tajimaD"} {print $1, $2, $3, ($3-$2)/$4}' | \
sed -e '2d'   > $POP.transformedThetas.filtered.windows.Xchr.$FEATURE

done 
done


# Lo que hago en este script es: primero quedarme solo con la columna de watterson, de pi y luego de la diferencia y la diferencia al cuadrado. 
# La de la diferencia al cuadrado la calculo ya, porque he encontradoun problema cuando la intentaba calcular en la slidding window de la forma 
# sumsq3+=$3^2
# A veces me daba problema y creo que es por la slidding window,porque cuando lo usaba esto mismo en el script de per unit no tenía este problema y además parece cambiante de como define las ventanas, lo cual es un poco extraño. Esto quiere decir, yo había detectado un problema en la ventana 40000, y si recortaba dejando las 40000 primeras bases pasaba. Si esto lo recortaba un poco mas y me quedaba con las 20000 ultimas, teninedo en cuenta que la ventana es de 10000, pasaba, pero si recortaba y me quedaba con las 10000 ultimas no pasaba, a pesar de que el problema era en esta ventana. 

# No he entendido bien porque pasa esto, pero me he dado cuenta de que si lo defino antes no pasa, asi que en la preimera parte (primer awk) me quedo con las columnas de interes y calculo el cuadrado de la diferencia. 
# En el script de despues que es una modificación de este: https://shearnrylan.wordpress.com/2016/05/30/sliding-window-in-awk/, calculo la media para pi y watterson, y además la standard deviation de la diferencia definido como: raiz cuadrada((suma de (valores)^2 (que en este caso es diferencia entre pi y watterson)- ((suma de valores)^2/numero de lineas) )/numero de lineas).
# En el siguiente awk lo que hago es calcular la tajima en si, que es pi - wateerson / sd de la diferencia. 
# Por último con sed -e '2d' me quito la segunda linea que corresponde a media ventana que hace al rpincipio. Si las ventnaas son de 10000, al principio hace una de 5000 que son los pasos y no he sabido quitarlo con el awk. 


## Actualización:

# Parece que el problema que estoy encontrando con awk, que me devuelve error de que en ocasiones la sqrt la está haciendo de un numero negativo, es debido a la precisión de los numeros. Por ahora no me preocupa, porque afecta a cuando los valores de diversidad son extremadamente bajos, y por tanto, estos se eliminaría. Lo que tengo que hacer a posteriori es filtrar, de alguna manera las diversidades para quedarme solo con aquellas ventanas que presenten diversidad y descartar la tajima calculada sobre vetnanas sin diversidad.  




```

# Join per pop

```{bash}
cd /home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature

POPS=(c_ll_ki_n008 c_ll_po_n008 c_ll_no_n008 c_lp_do_n012 c_lp_sm_n012)
FEATURES=(intergenic CDS intron intron_lncRNA lncRNA ncRNA promoter_gene_1000 promoter_lncRNA_1000 UCNE 3UTR 5UTR)


## Xchr

for POP in "${POPS[@]}"
do 
rm $POP.transformedThetas.filtered.windows.Xchr
echo -e "coord_end\tave_watterson\tave_pairwise\ttajimaD\tfeature\tpop" > $POP.transformedThetas.filtered.windows.Xchr
echo $POP
for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
awk -v OFS="\t" -v FEATURE="$FEATURE" -v POP="$POP" ' {print $0, FEATURE, POP}' <(tail -n+2 $POP.transformedThetas.filtered.windows.Xchr.$FEATURE) >> $POP.transformedThetas.filtered.windows.Xchr
done
done

###
# Auto

for POP in "${POPS[@]}"
do 
rm $POP.transformedThetas.filtered.windows.auto
echo -e "coord_end\tave_watterson\tave_pairwise\ttajimaD\tfeature\tpop" > $POP.transformedThetas.filtered.windows.auto
echo $POP
for FEATURE in "${FEATURES[@]}"
do
echo $FEATURE
awk -v OFS="\t" -v FEATURE="$FEATURE" -v POP="$POP" ' {print $0, FEATURE, POP}' <(tail -n+2 $POP.transformedThetas.filtered.windows.auto.$FEATURE) >> $POP.transformedThetas.filtered.windows.auto
done
done
```


# Download to local

```{bash}
scp -p mlucena@genomics-b.ebd.csic.es:/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/*.windows.Xchr /Users/marialucenaperez/Documents/WG_lynx_diversity_per_windows_features/raw

scp -p mlucena@genomics-b.ebd.csic.es:/home/mlucena/ANGSD_analysis/whole_genome_analysis/sfs/diversity_window_feature/*.windows.auto /Users/marialucenaperez/Documents/WG_lynx_diversity_per_windows_features/raw

```

# R
# Create dataframes

## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(psych)
library(ggpubr)
library(boot)
library(broom)
library(ggpubr)
library(ggrepel)
library(ggpmisc)
library(gridExtra)
library(mgcv)
library(MuMIn)

sample.wtd.mean <- function(x, w, d) {
    return(weighted.mean(x = x[d], w = w[d], na.rm=T ))
}

wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/"
wd_input <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_windows_features/raw/"
```

## Load pre-data

```{r}

c_ll_ki_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_ki_n008.transformedThetas.filtered.windows.auto", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[1]) %>% mutate (type_chr="auto") %>% mutate (Population="Kirov") %>% mutate (feature=as.factor(feature))


c_ll_no_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_no_n008.transformedThetas.filtered.windows.auto", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color = viridis_pal()(5)[2]) %>% mutate (type_chr="auto") %>% mutate (Population="Norway") %>% mutate (feature=as.factor(feature))

c_ll_po_n008_diversity_windows_auto <- read.csv(paste(wd_input, "c_ll_po_n008.transformedThetas.filtered.windows.auto", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[3]) %>% mutate (type_chr="auto") %>% mutate (Population="Poland") %>% mutate (feature=as.factor(feature))

c_lp_sm_n012_diversity_windows_auto <- read.csv(paste(wd_input, "c_lp_sm_n012.transformedThetas.filtered.windows.auto", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#5DC863FF") %>% mutate (type_chr="auto") %>% mutate (Population="Andujar") %>% mutate (feature=as.factor(feature))

c_lp_do_n012_diversity_windows_auto <- read.csv(paste(wd_input, "c_lp_do_n012.transformedThetas.filtered.windows.auto", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#FDE725FF") %>% mutate (type_chr="auto") %>% mutate (Population="Donana") %>% mutate (feature=as.factor(feature))


### 

c_ll_ki_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_ki_n008.transformedThetas.filtered.windows.Xchr", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[1]) %>% mutate (type_chr="Xchr") %>% mutate (Population="Kirov") %>% mutate (feature=as.factor(feature))

c_ll_no_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_no_n008.transformedThetas.filtered.windows.Xchr", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color = viridis_pal()(5)[2]) %>% mutate (type_chr="Xchr") %>% mutate (Population="Norway") %>% mutate (feature=as.factor(feature))

c_ll_po_n008_diversity_windows_X <- read.csv(paste(wd_input, "c_ll_po_n008.transformedThetas.filtered.windows.Xchr", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  viridis_pal()(5)[3]) %>% mutate (type_chr="Xchr") %>% mutate (Population="Poland") %>% mutate (feature=as.factor(feature))

c_lp_sm_n012_diversity_windows_X <- read.csv(paste(wd_input, "c_lp_sm_n012.transformedThetas.filtered.windows.Xchr", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#5DC863FF") %>% mutate (type_chr="Xchr") %>% mutate (Population="Andujar") %>% mutate (feature=as.factor(feature))

c_lp_do_n012_diversity_windows_X <- read.csv(paste(wd_input, "c_lp_do_n012.transformedThetas.filtered.windows.Xchr", sep=""), header=T, na.strings=c("NA", "na"), stringsAsFactors=F, row.names=NULL, sep="\t", dec=".") %>% mutate (., color =  "#FDE725FF") %>% mutate (type_chr="Xchr") %>% mutate (Population="Donana") %>% mutate (feature=as.factor(feature))




```

http://ianmadd.github.io/pages/PeakDensityDistribution.html
## Density plot watterson
Now we are plotting a density plot of the diversity (watterson and pi) of the populations. Those are bimodal. Therefore I will get the lowest value of this density plot in order to stablish a threshold for "no diverse" vs "diverse" units. We will used this threshold for Tajima plot. 
```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
  
DATAFRAME <- get(DATAFRAME_USED) 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop=as.character(pop)) %>% .[1,1] 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
print (DATAFRAME_USED)
DATAFRAME$ave_pairwise <- as.numeric(DATAFRAME$ave_pairwise)
DATAFRAME$ave_watterson <- as.numeric(DATAFRAME$ave_watterson)


if (POP=="c_lp_sm_n012" || POP=="c_ll_no_n008" && TYPE_CHR=="Xchr")
{
maxY1_position <- which.max(density(log10(DATAFRAME$ave_watterson))$y)
maxX1_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_watterson))$y[density(log10(DATAFRAME$ave_watterson))$x<(maxX1_value-1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_watterson))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY2_position] 
Densitywatterson.Y <- density(log10(DATAFRAME$ave_watterson))$y
Densitywatterson.X <- density(log10(DATAFRAME$ave_watterson))$x
minY_value <- min(Densitywatterson.Y[Densitywatterson.X > maxX2_value & Densitywatterson.X < maxX1_value])
minY_position <- which(Densitywatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_watterson))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_watterson"), c(POP,minX_value))
} else {
 maxY1_position <- which.max(density(log10(DATAFRAME$ave_watterson))$y)
maxX1_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_watterson))$y[density(log10(DATAFRAME$ave_watterson))$x>(maxX1_value+1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_watterson))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_watterson))$x[maxY2_position] 
Densitywatterson.Y <- density(log10(DATAFRAME$ave_watterson))$y
Densitywatterson.X <- density(log10(DATAFRAME$ave_watterson))$x
minY_value <- min(Densitywatterson.Y[Densitywatterson.X < maxX2_value & Densitywatterson.X > maxX1_value])
minY_position <- which(Densitywatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_watterson))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_watterson"), c(POP,minX_value))
}}

# Uno las distintas tablas de puntos de corte. 

density_min_values_watterson_auto <- as.data.frame(rbind (c_lp_sm_n012_auto_density_min_value_watterson, c_lp_do_n012_auto_density_min_value_watterson, c_ll_ki_n008_auto_density_min_value_watterson, c_ll_po_n008_auto_density_min_value_watterson, c_ll_no_n008_auto_density_min_value_watterson)) %>% mutate (type_chr="auto")
density_min_values_watterson_xchr <- as.data.frame(rbind (c_lp_sm_n012_Xchr_density_min_value_watterson, c_lp_do_n012_Xchr_density_min_value_watterson, c_ll_ki_n008_Xchr_density_min_value_watterson, c_ll_po_n008_Xchr_density_min_value_watterson, c_ll_no_n008_Xchr_density_min_value_watterson)) %>% mutate (type_chr="Xchr")

density_min_values_watterson <- as.data.frame(rbind(density_min_values_watterson_auto, density_min_values_watterson_xchr))

names(density_min_values_watterson) <- c("pop", "min_density_value_watterson", "type_chr")
density_min_values_watterson$min_density_value_watterson <- as.numeric(as.character(density_min_values_watterson$min_density_value_watterson))

rm (c_lp_sm_n012_auto_density_min_value_watterson)
rm (c_lp_sm_n012_Xchr_density_min_value_watterson)

rm (c_lp_do_n012_auto_density_min_value_watterson)
rm (c_lp_do_n012_Xchr_density_min_value_watterson)

rm (c_ll_ki_n008_auto_density_min_value_watterson)
rm (c_ll_ki_n008_Xchr_density_min_value_watterson)

rm (c_ll_po_n008_auto_density_min_value_watterson)
rm (c_ll_po_n008_Xchr_density_min_value_watterson)

rm (c_ll_no_n008_auto_density_min_value_watterson) 
rm (c_ll_no_n008_Xchr_density_min_value_watterson) 

rm (density_min_values_watterson_auto)
rm (density_min_values_watterson_xchr)
rm (DATAFRAME)
```

## Density plot pairwise

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
  
  
DATAFRAME <- get(DATAFRAME_USED) 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop=as.character(pop)) %>% .[1,1] 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
print (DATAFRAME_USED)

# Esto lo hago porque el pico más alto está en la deecha en este ejemplo concreto por eso tengo que buscar el mínimo a la iquierda de este pico x<(maxvalue -1) & tb esta modificado esto: minY_value <- min(Densitypairwise.Y[Densitypairwise.X > maxX2_value & Densitypairwise.X < maxX1_value])

if (POP=="c_lp_sm_n012" && TYPE_CHR=="auto" )
{
maxY1_position <- which.max(density(log10(DATAFRAME$ave_pairwise))$y)
maxX1_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_pairwise))$y[density(log10(DATAFRAME$ave_pairwise))$x<(maxX1_value-1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_pairwise))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$ave_pairwise))$y
Densitypairwise.X <- density(log10(DATAFRAME$ave_pairwise))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X > maxX2_value & Densitypairwise.X < maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_pairwise))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_pairwise"), c(POP,minX_value))

}else{

maxY1_position <- which.max(density(log10(DATAFRAME$ave_pairwise))$y)
maxX1_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$ave_pairwise))$y[density(log10(DATAFRAME$ave_pairwise))$x>(maxX1_value+1)])
maxY2_position <- which(density(log10(DATAFRAME$ave_pairwise))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$ave_pairwise))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$ave_pairwise))$y
Densitypairwise.X <- density(log10(DATAFRAME$ave_pairwise))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X < maxX2_value & Densitypairwise.X > maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$ave_pairwise))$x[minY_position] 
assign(paste0(POP,"_", TYPE_CHR,"_density_min_value_pairwise"), c(POP,minX_value))
}
}

# Uno las distintas tablas de puntos de corte. 

density_min_values_pairwise_auto <- as.data.frame(rbind (c_lp_sm_n012_auto_density_min_value_pairwise, c_lp_do_n012_auto_density_min_value_pairwise, c_ll_ki_n008_auto_density_min_value_pairwise, c_ll_po_n008_auto_density_min_value_pairwise, c_ll_no_n008_auto_density_min_value_pairwise)) %>% mutate (type_chr="auto")
density_min_values_pairwise_xchr <- as.data.frame(rbind (c_lp_sm_n012_Xchr_density_min_value_pairwise, c_lp_do_n012_Xchr_density_min_value_pairwise, c_ll_ki_n008_Xchr_density_min_value_pairwise, c_ll_po_n008_Xchr_density_min_value_pairwise, c_ll_no_n008_Xchr_density_min_value_pairwise)) %>% mutate (type_chr="Xchr")

density_min_values_pairwise <- as.data.frame(rbind(density_min_values_pairwise_auto, density_min_values_pairwise_xchr))

names(density_min_values_pairwise) <- c("pop", "min_density_value_pairwise", "type_chr")
density_min_values_pairwise$min_density_value_pairwise <- as.numeric(as.character(density_min_values_pairwise$min_density_value_pairwise))

rm (c_lp_sm_n012_auto_density_min_value_pairwise)
rm (c_lp_sm_n012_Xchr_density_min_value_pairwise)

rm (c_lp_do_n012_auto_density_min_value_pairwise)
rm (c_lp_do_n012_Xchr_density_min_value_pairwise)

rm (c_ll_ki_n008_auto_density_min_value_pairwise)
rm (c_ll_ki_n008_Xchr_density_min_value_pairwise)

rm (c_ll_po_n008_auto_density_min_value_pairwise)
rm (c_ll_po_n008_Xchr_density_min_value_pairwise)

rm (c_ll_no_n008_auto_density_min_value_pairwise) 
rm (c_ll_no_n008_Xchr_density_min_value_pairwise) 

rm (density_min_values_pairwise_auto)
rm (density_min_values_pairwise_xchr)
rm (DATAFRAME)
```

## Create new variable low values to zero
Now I create a new variable replacing the diversity of units below the minimun of the density plot by 0; i.e. below the minimum value of the bimodal distributions, units are not variable, and hence, 0. 
```{r}

DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
DATAFRAME <- get(DATAFRAME_USED) 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 

if (TYPE_CHR=="auto"){
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="auto") 
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="auto") 

} else { 
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="Xchr")
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="Xchr") 

}
  
DATAFRAME_MODIF <- DATAFRAME %>% 
  dplyr::mutate (watterson_zero = ifelse (
pop=="c_lp_sm_n012"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_lp_sm_n012")$min_density_value_watterson) | 
pop=="c_lp_do_n012"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_lp_do_n012")$min_density_value_watterson) | 
pop=="c_ll_ki_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_ki_n008")$min_density_value_watterson) | 
pop=="c_ll_po_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_po_n008")$min_density_value_watterson) | 
pop=="c_ll_no_n008"&log10(ave_watterson)<(filter(density_min_values_watterson_filtered,pop=="c_ll_no_n008")$min_density_value_watterson),0,ave_watterson)) %>% 
  dplyr::mutate (pairwise_zero = ifelse (pop=="c_lp_sm_n012"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_lp_sm_n012")$min_density_value_pairwise) | 
pop=="c_lp_do_n012"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_lp_do_n012")$min_density_value_pairwise) | 
pop=="c_ll_ki_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_ki_n008")$min_density_value_pairwise) | 
pop=="c_ll_po_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_po_n008")$min_density_value_pairwise) | 
pop=="c_ll_no_n008"&log10(ave_pairwise)<(filter(density_min_values_pairwise_filtered,pop=="c_ll_no_n008")$min_density_value_pairwise),0,ave_pairwise)) %>%
  dplyr::mutate(tajimaD_transformed = ifelse(watterson_zero!="0" | pairwise_zero!="0", tajimaD, NA)) %>% select (-tajimaD) %>%  dplyr::rename(.,"tajimaD"="tajimaD_transformed")
assign(paste0(DATAFRAME_USED), DATAFRAME_MODIF , envir = globalenv() )

}
```

# Plot

```{r}

DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto", "c_ll_po_n008_diversity_windows_auto", "c_ll_no_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto", "c_lp_do_n012_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_X", "c_ll_po_n008_diversity_windows_X", "c_ll_no_n008_diversity_windows_X", "c_lp_sm_n012_diversity_windows_X", "c_lp_do_n012_diversity_windows_X")


for (DATAFRAME_USED in DATAFRAMES) 
{
DATAFRAME <- get(DATAFRAME_USED) 
TYPE_CHR=get(DATAFRAME_USED) %>% select(type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1] 
POP=get(DATAFRAME_USED) %>% select(pop) %>% mutate(pop.x=as.character(pop)) %>% .[1,1] 

if (TYPE_CHR=="auto"){
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="auto") 
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="auto") 

} else { 
  density_min_values_watterson_filtered <- filter(density_min_values_watterson, type_chr=="Xchr")
  density_min_values_pairwise_filtered <- filter(density_min_values_pairwise, type_chr=="Xchr") 

}
  
# Pairwise:
min_pop_value_pairwise <- as.numeric(density_min_values_pairwise_filtered %>% dplyr::filter(pop==POP) %>% .[1,2] )
min_pop_value_watterson <- as.numeric(density_min_values_watterson_filtered %>% dplyr::filter(pop==POP) %>% .[1,2] )

ggplot (DATAFRAME , aes(log10(ave_pairwise)))+
  geom_density()+
  geom_vline(xintercept= min_pop_value_pairwise, color='grey20') +
  ggsave (paste0(wd_output, POP, "_", TYPE_CHR, "_pairwise_density.pdf"))


ggplot (DATAFRAME , aes(log10(ave_watterson)))+
  geom_density()+
  geom_vline(xintercept= min_pop_value_watterson, color='grey20') +
ggsave (paste0(wd_output, POP, "_", TYPE_CHR, "_watterson_density.pdf"))

#

}


```


# Create comparison dataframe.

```{r}

create_data_diversity_bootleneck_vs_non_bootleneck <- function(POP1, POP2, name_POP1, name_POP2){
    POPULATION1=POP1 %>% select(pop) %>% mutate(Populations=as.character(pop)) %>% .[1,1] 
    POPULATION2=POP2 %>% select(pop) %>% mutate(Populations=as.character(pop)) %>% .[1,1] 
  data_diversity_POP1_POP2 <- dplyr::inner_join (POP1, POP2, by = c("coord_end", "feature", "type_chr")) %>%  
      # Calculo el delta 
    dplyr::mutate (delta_pairwise = (as.numeric(ave_pairwise.y) - as.numeric(ave_pairwise.x))) %>%
    dplyr::mutate (delta_watterson = (as.numeric(ave_watterson.y) - as.numeric(ave_watterson.x))) %>% 
    dplyr::mutate (delta_pairwise_corrected = (as.numeric(ave_pairwise.y) - as.numeric(ave_pairwise.x))/(as.numeric(ave_pairwise.y) + as.numeric(ave_pairwise.x))) %>% 
    dplyr::mutate (delta_watterson_corrected = ((as.numeric(ave_watterson.y) - as.numeric(ave_watterson.x))/(as.numeric(ave_watterson.y) + as.numeric(ave_watterson.x)))) %>% 
    dplyr::mutate (delta_tajimaD=(as.numeric(tajimaD.y)-as.numeric(tajimaD.x))) %>% 
    dplyr::mutate (delta_w_delta_p=delta_watterson_corrected-delta_pairwise_corrected) %>% 
       # Add comparison title  
    dplyr::mutate(comparison=paste(POPULATION1, "-", POPULATION2, sep=""))
  dataframename <- paste (name_POP1, name_POP2, sep="_")
  assign (dataframename, data_diversity_POP1_POP2,.GlobalEnv)
}

# Autosomes
# Create data frame
# Dataframe Kirov-Norway
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_auto,c_ll_no_n008_diversity_windows_auto, deparse(substitute(c_ll_ki_n008_diversity_windows_auto)),deparse(substitute(c_ll_no_n008_diversity_windows_auto)))
# Dataframe Kirov-Poland
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_auto,c_ll_po_n008_diversity_windows_auto, deparse(substitute(c_ll_ki_n008_diversity_windows_auto)),deparse(substitute(c_ll_po_n008_diversity_windows_auto)))
# Dataframe Sierra_Morena-Doñana
create_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n012_diversity_windows_auto,c_lp_do_n012_diversity_windows_auto, deparse(substitute(c_lp_sm_n012_diversity_windows_auto)),deparse(substitute(c_lp_do_n012_diversity_windows_auto)))


## X chr
# Dataframe Kirov-Norway
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_X,c_ll_no_n008_diversity_windows_X, deparse(substitute(c_ll_ki_n008_diversity_windows_X)),deparse(substitute(c_ll_no_n008_diversity_windows_X)))
# Dataframe Kirov-Poland
create_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n008_diversity_windows_X,c_ll_po_n008_diversity_windows_X, deparse(substitute(c_ll_ki_n008_diversity_windows_X)),deparse(substitute(c_ll_po_n008_diversity_windows_X)))
# Dataframe Sierra_Morena-Doñana
create_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n012_diversity_windows_X,c_lp_do_n012_diversity_windows_X, deparse(substitute(c_lp_sm_n012_diversity_windows_X)),deparse(substitute(c_lp_do_n012_diversity_windows_X)))

# Combine comparisons
#all_comparisons_diversity_bootleneck_vs_non_bootleneck_window <- rbind (c_ll_ki_n008_diversity_windows_c_ll_no_n008_diversity_windows, c_ll_ki_n008_diversity_windows_c_ll_po_n008_diversity_windows, c_lp_sm_n012_diversity_windows_c_lp_do_n012_diversity_windows)

```

## *Delta distribution
```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")

for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
 # Watterson
   # Plot de la distribución de delta corregida
  ggplot(get(DATAFRAME), aes(x=(delta_watterson_corrected))) + 
    geom_histogram() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_watterson_corrected_average_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
    aes(x = delta_watterson_corrected) +
    geom_histogram() +
    facet_wrap(~feature, scales = "free")  +
    theme(axis.text.x = element_text(angle=90, hjust=1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_watterson_corrected_average_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

 # PI
  # Plot de la distribución de delta corregida
 ggplot(get(DATAFRAME), aes(x=(delta_pairwise_corrected))) + 
    geom_histogram() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_pairwise_corrected_average_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
    aes(x = delta_pairwise_corrected) +
    geom_histogram() +
    facet_wrap(~feature, scales = "free")  +
    theme(axis.text.x = element_text(angle=90, hjust=1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_pairwise_corrected_average_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")
 
 # Delta delta
 
  ggplot(get(DATAFRAME), aes(x=(delta_w_delta_p))) + 
    geom_histogram() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_D_distribution.pdf", sep=""))
  # Plot de la distribución de delta para cada feature
 ggplot(get(DATAFRAME)) + 
    aes(x = delta_w_delta_p) +
    geom_histogram() +
    facet_wrap(~feature, scales = "free")  +
    theme(axis.text.x = element_text(angle=90, hjust=1)) +
    ggsave (paste(wd_output,DATAFRAME,"_delta_D_distribution_per_feature.pdf", sep=""), width = 25, height = 25, units = "cm")

 
}

```

## *Test for normality of D

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto")

for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
Shapiro_results <- get(DATAFRAME) %>%
  dplyr::group_by(feature) %>%
  dplyr::sample_n(200) %>% 
  summarise(statistic = shapiro.test(delta_w_delta_p)$statistic,
            p.value = shapiro.test(delta_w_delta_p)$p.value) %>% as.data.frame()

write.table(format(Shapiro_results, digits=8, scientific=T), paste(wd_output,DATAFRAME,"_shapiro_test.txt",sep=""), row.names = F)
}


```
Como la mayoría son no normales hacemos test de U-Mann Whitney.

## U-Mann Whitney
```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto")

for (DATAFRAME in DATAFRAMES) 
{
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
wilcox_test_df <- pairwise.wilcox.test(get(DATAFRAME)$delta_w_delta_p, get(DATAFRAME)$feature, p.adjust.method = "bonferroni") 

wilcox_test_df_reshape <-melt(wilcox_test_df[[3]]) %>% 
  filter (!is.na(value)) %>% 
  mutate (SIG=ifelse(value<0.05, "SIGN", "no")) %>% 
  mutate (comparison = paste0(POP1,"_", POP2)) %>% 
  mutate (method = "wilcox.test") %>% 
  mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008_c_ll_po_n008", "Kirov_Poland",
          ifelse (comparison == "c_ll_ki_n008_c_ll_no_n008", "Kirov_Norway",
          ifelse (comparison == "c_lp_sm_n012_c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison)

write.table(format(wilcox_test_df_reshape, digits=8, scientific=T), paste(wd_output,DATAFRAME,"_wilcox_test.txt",sep=""), row.names = F, quote=F)

}

```

En mi local hago lo siguiente:

```{bash}
cat /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto_wilcox_test.txt <(tail -n +2 /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto_wilcox_test.txt ) <(tail -n +2 /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto_wilcox_test.txt )  > /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/window_per_feature/all_popx_windows_delta_D_distribution_auto_wilcox_test.txt
```



## *Sanity: Delta vs initial diversity

```{r}
ggplot (c_ll_ki_n008_diversity_windows_c_ll_no_n008_diversity_windows, aes(x = log(ave_watterson.x), y = delta_watterson_corrected))+
  geom_point() +
  geom_smooth()

ggplot (c_ll_ki_n008_diversity_windows_c_ll_no_n008_diversity_windows, aes(x = log10(ave_pairwise.x), y = delta_pairwise_corrected))+
  geom_point() +
  geom_smooth ()

```

## *Delta watterson and delta pi per pop and feature.

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")

DELTA_MEASURES=c("delta_watterson_corrected", "delta_pairwise_corrected")


scale_x_discrete2 <- function(..., expand = waiver(), position = "bottom") {
  sc <- discrete_scale(c("x", "xmin", "xmax", "xend"), "position_d", identity, ..., expand = expand, guide = "none", position = position, super = ScaleDiscretePositionFunc)
  sc$range_c <- ggplot2:::continuous_range()
  sc
}


for (DATAFRAME in DATAFRAMES) 
{
  for (DELTA_MEASURE in DELTA_MEASURES)
  {
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  type_chr=get(DATAFRAME) %>% select(type_chr) %>% .[1,1] 

  POPULATION1=get(DATAFRAME) %>% select(Population.x) %>% mutate(Population.x=as.character(Population.x)) %>% .[1,1] 
  POPULATION2=get(DATAFRAME) %>% select(Population.y) %>% mutate(Population.y=as.character(Population.y)) %>% .[1,1] 
  
ggplot(get(DATAFRAME), aes_string(x="feature", y=DELTA_MEASURE))+
      stat_summary(fun.data = "mean_cl_boot", size = 0.1) +
      coord_flip() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
#      scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
#      scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  # PONER EL VALOR DEL GENERAL (ralla?)
#scale_fill_viridis_d(option = "magma")+
#scale_colour_viridis_d(option = "magma")+
#scale_x_discrete2(limits = rev)+

ggsave (paste(wd_output,POP1, "_", POP2, "_", DELTA_MEASURE,"_", type_chr, ".pdf", sep=""), width = 80, height = 80, units = "mm")
}
}

```

# *Delta_D per pop and feature. 

```{r}
DATAFRAMES=c("c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto", "c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto", "c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X", "c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X")

# AUTO
comparison_pops_auto <- rbind (c_ll_ki_n008_diversity_windows_auto_c_ll_no_n008_diversity_windows_auto, c_ll_ki_n008_diversity_windows_auto_c_ll_po_n008_diversity_windows_auto, c_lp_sm_n012_diversity_windows_auto_c_lp_do_n012_diversity_windows_auto) %>% 
   mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008-c_ll_po_n008", "Kirov_Poland",
          ifelse (comparison == "c_ll_ki_n008-c_ll_no_n008", "Kirov_Norway",
          ifelse (comparison == "c_lp_sm_n012-c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison) %>% 
  mutate(comparison=pop1_pop2) %>% 
  select (-pop1_pop2)

comparison_pops_auto$feature <- plyr::revalue(comparison_pops_auto$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))
comparison_pops_auto$feature <- factor (comparison_pops_auto$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

comparison_pops_auto$comparison <- factor (comparison_pops_auto$comparison, levels=c("Kirov_Poland", "Kirov_Norway", "Andujar_Donana"))

comparison_pops_auto_summary <- comparison_pops_auto %>% 
             dplyr::group_by(feature, comparison) %>%
             dplyr::summarise(
                       mean_delta_watterson=mean(delta_watterson_corrected, na.rm = TRUE),
                       se_mean_delta_watterson = sd(boot(delta_watterson_corrected, sample.wtd.mean, R = 100)$t),
                       mean_delta_pairwise=mean(delta_pairwise_corrected, na.rm = TRUE),
                       se_mean_delta_pairwise = sd(boot(delta_pairwise_corrected, sample.wtd.mean, R = 100)$t))

ggplot(data=comparison_pops_auto_summary, aes(mean_delta_pairwise, mean_delta_watterson)) +
  geom_point(aes(colour=feature, fill=feature))+
  scale_fill_viridis_d(option = "plasma")+
  scale_colour_viridis_d(option = "plasma")+
  geom_abline (colour="grey", linetype = "dashed") +
  geom_errorbar(aes(ymin=mean_delta_watterson-se_mean_delta_watterson, ymax=mean_delta_watterson+se_mean_delta_watterson, colour=feature, fill=feature)) +
  geom_errorbarh(aes(xmin = mean_delta_pairwise - se_mean_delta_pairwise, xmax = mean_delta_pairwise + se_mean_delta_pairwise, colour=feature, fill=feature)) +
  facet_wrap(~comparison)+
  geom_text_repel(aes(label = feature),
                  box.padding   = 1, 
                  point.padding = 0.1,
                  size          = 2.5,
                  force         = 80,
                  segment.size  = 0.2,
                  segment.color = 'grey50') +
  theme(legend.position = "none") +
  ggsave (paste(wd_output,"delta_pi_vs_delta_watterson_auto.pdf", sep=""), width = 160, height = 80, units = "mm")

ggplot(comparison_pops_auto, aes(x=feature, y=delta_w_delta_p, colour=comparison, fill=comparison, shape=comparison))+
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
  stat_summary(fun.y = mean,
               geom = "line")+
  coord_flip() +
  facet_wrap (~comparison) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")+
  scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
ggsave (paste(wd_output,"delta_delta_all_pops_auto_separated.pdf", sep=""), width = 160, height = 80, units = "mm")

# Xchr
comparison_pops_Xchr <- rbind (c_ll_ki_n008_diversity_windows_X_c_ll_no_n008_diversity_windows_X, c_ll_ki_n008_diversity_windows_X_c_ll_po_n008_diversity_windows_X, c_lp_sm_n012_diversity_windows_X_c_lp_do_n012_diversity_windows_X) %>% 
   mutate (pop1_pop2 = ifelse (comparison == "c_ll_ki_n008-c_ll_po_n008", "Kirov_Poland",
          ifelse (comparison == "c_ll_ki_n008-c_ll_no_n008", "Kirov_Norway",
          ifelse (comparison == "c_lp_sm_n012-c_lp_do_n012", "Andujar_Donana", "NA")))) %>% 
  select (-comparison) %>% 
  mutate(comparison=pop1_pop2) %>% 
  select (-pop1_pop2)

comparison_pops_Xchr$feature <- plyr::revalue(comparison_pops_Xchr$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))
comparison_pops_Xchr$feature <- factor (comparison_pops_Xchr$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

comparison_pops_Xchr$comparison <- factor (comparison_pops_Xchr$comparison, levels=c("Kirov_Poland", "Kirov_Norway", "Andujar_Donana"))



comparison_pops_Xchr_summary <- comparison_pops_Xchr %>% 
             dplyr::group_by(feature, comparison) %>%
             dplyr::summarise(
                       mean_delta_watterson=mean(delta_watterson_corrected, na.rm = TRUE),
                       se_mean_delta_watterson = sd(boot(delta_watterson_corrected, sample.wtd.mean, R = 100)$t),
                       mean_delta_pairwise=mean(delta_pairwise_corrected, na.rm = TRUE),
                       se_mean_delta_pairwise = sd(boot(delta_pairwise_corrected, sample.wtd.mean, R = 100)$t))

ggplot(data=comparison_pops_Xchr_summary, aes(mean_delta_pairwise, mean_delta_watterson)) +
  geom_point(aes(colour=feature, fill=feature))+
  scale_fill_viridis_d(option = "plasma")+
  scale_colour_viridis_d(option = "plasma")+
  geom_abline (colour="grey", linetype = "dashed") +
  geom_errorbar(aes(ymin=mean_delta_watterson-se_mean_delta_watterson, ymax=mean_delta_watterson+se_mean_delta_watterson, colour=feature, fill=feature)) +
  geom_errorbarh(aes(xmin = mean_delta_pairwise - se_mean_delta_pairwise, xmax = mean_delta_pairwise + se_mean_delta_pairwise, colour=feature, fill=feature)) +
  facet_wrap(~comparison)+
  geom_text_repel(aes(label = feature),
                  box.padding   = 1, 
                  point.padding = 0.1,
                  size          = 2.5,
                  force         = 80,
                  segment.size  = 0.2,
                  segment.color = 'grey50') +
  theme(legend.position = "none") +
  ggsave (paste(wd_output,"delta_pi_vs_delta_watterson_Xchr.pdf", sep=""), width = 160, height = 80, units = "mm")



ggplot(comparison_pops_Xchr, aes(x=feature, y=delta_w_delta_p, colour=comparison, fill=comparison, shape=comparison))+
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
  stat_summary(fun.y = mean,
               geom = "line")+
  coord_flip() +
  facet_wrap (~comparison) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")+
  scale_fill_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
  scale_color_manual(values=c("#588C7E", "#F2AE72", "#8C4646")) +
ggsave (paste(wd_output,"delta_delta_all_pops_Xchr.pdf", sep=""), width = 160, height = 80, units = "mm")
```



