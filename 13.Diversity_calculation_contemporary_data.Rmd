---
title: "13.Diversity_calculation_contemporary_data"
output: html_document
---

En este script voy a hacer los análisis de diversidad para las poblaciones contemporaneas. 

Ahora tengo que descargarme todos los archivos de cada población y despues hacer un super-join para cada población para acabar haciendo una unica tabla con rbind con todas las poblaciones. 

# Create dataframe

```{r}
# https://github.com/MTFA/CohortEx/wiki/Run-rJava-with-RStudio-under-OSX-10.10,-10.11-(El-Capitan)-or-10.12-(Sierra)

# Ahora hago un join de la tabla principal de diversidad con las de telómeros, centrómeros y cromosoma. 
library(dplyr)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"

# Ojo! antes de correr esto, asegurarme que no lo he corrido antes porque si no estoy haciendo append a las tablas viejas y no creando nuevas. --> YA NO PASA ESTO PQ LO TENGO EN CARPETAS DISTINTAS!!!!

poplist <- c("c_ll_ki_n013", "c_ll_po_n008","c_ll_no_n008","c_lp_sm_n019", "c_lp_do_n012")

  
for (pop in poplist)
{
  if (exists("dataset"))
  {rm (dataset)
  }
  
  files_for_given_pop <- list.files(path = wd_in, pattern = pop)
  
  for (file_for_given_pop in files_for_given_pop)
  {
    message (file_for_given_pop)
    # if the merged dataset doesn't exist, create it
    if (!exists("dataset"))
    {
      dataset <- read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t") 
    }
    
    # if the merged dataset does exist, append to it
    if (exists("dataset"))
    {
      temp_dataset <-read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t", na.strings = c("NA", "na"))
      dataset <- dplyr::full_join(dataset, temp_dataset, by = c("scaffold", "start_cero_based", "end", "length", "NAs", "informative_sites", "feature", "strandness", "frame", "id_gene", "id", "watterson_ave", "watterson_sd", "pairwise_ave", "pairwise_sd", "tajimaD", "pop", "specie", "epoch"))   
      rm(temp_dataset)
      assign(pop, dataset) # Con esto quiero ponerle el nombre de la población a la dataframe. 
    }
  }    
}



rm(dataset)



data_diversity_raw <-rbind(c_ll_ki_n013,c_ll_po_n008,c_ll_no_n008,c_lp_sm_n019,c_lp_do_n012) %>% 
    mutate( watterson_ave = as.numeric(gsub("\\*10\\^","e",watterson_ave)),
            watterson_sd = as.numeric(gsub("\\*10\\^","e",watterson_sd)),
            pairwise_ave  = as.numeric(gsub("\\*10\\^","e",pairwise_ave)),
            pairwise_sd  = as.numeric(gsub("\\*10\\^","e",pairwise_sd)),
            tajimaD = as.numeric(gsub("\\*10\\^","e",tajimaD)))


write.table (data_diversity_raw, paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n013, paste(wd_out, "c_ll_ki_n013.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n008, paste(wd_out, "c_ll_ki_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_no_n008, paste(wd_out, "c_ll_no_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_po_n008, paste(wd_out, "c_ll_po_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_do_n012, paste(wd_out, "c_ll_do_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_sm_n019, paste(wd_out, "c_ll_sm_n019.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
#write.table (c_lp_sm_n012, paste(wd_out, "c_ll_sm_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
```

# -------------------------------------------------
# Modifying data 1
Las modificaciones a la tabla están separadas en dos, porque es mas facil para poder retormarlo en cualquiera de los dos puntos y no tener que cargarlo todo desde el principio. 
## Load library & wd
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"
wd_GC <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/GC_content"
wd_site_density <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/functional_sites_density/"

```

## Load df
```{r}
# data_diversity <- data_diversity_raw 
# En teoría debería de funcionar llamando a la tabla anterior, pero como no funciona no le doy más vueltas. Me he descargado la raw y la he vuelto a cargar, que así funcionaba antes, y así ha funcionado ahora. 

data_diversity <- read.table(paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), header=T, na.strings = c("NA", "na"), stringsAsFactors = F) %>%  
  replace(., is.na(.), "0") %>%  # Para que pueda calcular cuando es mayor o menor que 75%; si es NA no lo reconoce. 
  dplyr::mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar",  
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  dplyr::mutate (., Species =ifelse (specie=="ll", "L.lynx", 
                   ifelse (specie=="lp", "L.pardinus", NA))) %>% 
  # Anoto qué es cada región excluyendo las de los chr F1 y F2 centromero y telómero. 
  dplyr::mutate (., region = ifelse (chr.x=="chrF2" & centr_percentage >= 0.75, NA, 
                             ifelse (chr.x=="chrF2" & tel2m_percentage >= 0.75, NA,
                             ifelse (tel2m_percentage >= 0.75, "Telomere_2m", 
                             ifelse (centr_percentage >= 0.75, "Centromere", "Interstitial" )))))  %>% 
  # Ahora elimino la barra baja que encuentro en algunos de los lncRNA
  #mutate(new_id=ifelse(feature=="lncRNA", substr(.$id_gene,start=1,stop=13), as.character(id_gene))) %>% 
  #select(-id_gene) %>% 
  #dplyr::rename(id_gene = new_id) %>% 
  # Creo un identificador único para luego poder filtrar por este cuando tenga que sacar los comunes a todas las poblaciones. 
  dplyr::mutate (., chr = ifelse (chr.x == chr.y, as.character(chr.x), "PROBLEMA")) %>% 
  dplyr::mutate (., cat_position_start = ifelse (cat_position_start.x ==cat_position_start.y, as.numeric (cat_position_start.x), "PROBLEMA")) %>%   dplyr::mutate (., cat_position_end = ifelse (cat_position_end.x ==cat_position_end.y, as.numeric (cat_position_end.x), "PROBLEMA")) %>% 
  dplyr::select (-c(chr.x, chr.y, cat_position_start.x, cat_position_start.y, cat_position_end.x, cat_position_end.y)) %>% 
  mutate (., unique_id = paste (id,feature, sep="_")) %>% 
  #Haciendo este mutate lo que hago es modificar el valor de watterson para tener en ucenta el tamaño poblacional verdadero de la población (chr) cuando consideramos la diferencia entre machos y hembras. En el xls modif_a_watterson_chrX viene explicado. 
  mutate (., watterson_modif = ifelse (chr=="chrX" & pop == "c_ll_ki_n013", watterson_ave * 1.09, 
                               ifelse (chr=="chrX" & pop == "c_ll_po_n008", watterson_ave * 1.12,
                               ifelse (chr=="chrX" & pop == "c_ll_no_n008", watterson_ave * 1.15,
                               ifelse (chr=="chrX" & pop == "c_lp_sm_n019", watterson_ave * 1.07, 
                               ifelse (chr=="chrX" & pop == "c_lp_do_n012", watterson_ave * 1.10, watterson_ave)))))) %>% 
  dplyr::select (., -watterson_ave) %>% 
  dplyr::rename(watterson_ave = watterson_modif) %>% 
  dplyr::rowwise() %>%
 # los promotores de los lncRNA siguen llamandose igual, y ojo que están sacados de la notación de los propios lncrNA pero sin tener en cuenta los distintos transcritos.
  dplyr::mutate(new_id = ifelse ( feature=="lncRNA" | feature =="intron_lncRNA",substr(as.character(id_gene), start = 1, stop = 13), as.character(id_gene))) %>% 
  dplyr::select (.,-id_gene) %>% 
  dplyr::rename(id_gene = new_id)
                                     

#View(data_diversity)
#unique(data_diversity$pop)
#unique(data_diversity$Populations)

#¡Ojo! el filtro que estás aplicando se está quedando con las que para la Tajima son NA. Si las quieres eliminar ¡ojo!
# 2248581

# Compruebo que efectivamente no hay ningún cromosoma que no encaje. 
# unique(data_diversity$chr)
# Está bien!
```
## Modifying dataframe
##1.$$ AQUI! Filtering por tamaño y transcritos

```{r}
# Ojo los lncRNA tienen más de un trasncrito, así que hay que eliminarlo. 
# En primer lugar vamos a sacar una lista para que luego la podamos filtrar. 
all_lncRNA <- data_diversity %>% ungroup(.) %>% dplyr::filter (pop=="c_ll_ki_n013") %>%  dplyr::filter (feature=="lncRNA"| feature=="intron_lncRNA" ) %>% dplyr::mutate(id2=id) %>% separate (id2,c("a", "b", "c", "d", "e"), "_", extra = "drop") %>% dplyr::mutate(new_id=paste(c,d, sep="_")) %>% dplyr::select (-c(a,b,c,d,e)) 

# Selecciono todos los que tienen más de un transcrito.
all_lncRNA_sum_lenght_repeted <- all_lncRNA %>% as.data.frame(.) %>% dplyr::group_by (id_gene, new_id) %>% dplyr::summarise (sum_length = sum(length)) %>% dplyr::group_by(id_gene) %>% dplyr::filter(n()>1)

# Me quedo con el más largo, y añado la información que se pierde al hacer el resumen de la identidad del transcrito. 
all_lncRNA_sum_lenght_repeted_large_length <- all_lncRNA_sum_lenght_repeted %>% dplyr::summarise(sum_length = max(sum_length))  %>%  dplyr::inner_join(., all_lncRNA_sum_lenght_repeted, by=c("id_gene", "sum_length"))

# Elimino duplicados en caso de que haya más de un transcrito con la misma longitud, quedandome con uno al azar--> Esta tabla sería la buena, con la que me tengo que quedar, asi que hago antijoin para lograr lo que tengo que tirar. 
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates <- all_lncRNA_sum_lenght_repeted_large_length[!duplicated(all_lncRNA_sum_lenght_repeted_large_length$id_gene),]


# La tabla que me tengo que quedar de los que tienen más de un transcrito.
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates
# La tabla de


# Selecciono el id de todos estos.
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id  <- dplyr::anti_join(all_lncRNA, all_lncRNA_sum_lenght_repeted_large_length_no_duplicates, by=c("id_gene", "new_id")) %>% dplyr::select("unique_id")





data_diversity_pre <- data_diversity %>% ungroup(.) %>%  
  dplyr::anti_join(all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id,by="unique_id") %>% 
  dplyr::filter (., informative_sites>=50) %>% 
  dplyr::filter (., informative_sites/length>=0.20) %>% 
  dplyr::filter (., !(feature=="promoter_gene_250")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_500")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_1000" & length < 1000)) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_250")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_500")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_1000" & length < 1000)) 


# Sanity check de que nada con las mismas coordenadas y con las misma longitud y strandness y frame se va a contar doble, pq no debería. 
# kk1 <- data_diversity_pre %>% mutate (position=paste(scaffold,start_cero_based,end, length, feature, strandness, frame, id_gene)) 
# kk2 <- as.data.frame(table (kk3$position)) %>% filter(Freq>5)

# Saco la lista de elementos comunes a todas las unidades para cada especie. 

# Primero par lynx lynx:

data_diversity_pre_ki <- data_diversity_pre %>% filter (pop=="c_ll_ki_n013")
data_diversity_pre_no <- data_diversity_pre %>% filter (pop=="c_ll_no_n008")
data_diversity_pre_po <- data_diversity_pre %>% filter (pop=="c_ll_po_n008")


lista_lynxlynx <- dplyr::inner_join(data_diversity_pre_ki, data_diversity_pre_no, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::inner_join(., data_diversity_pre_po, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id" ))  %>% select("unique_id")

data_diversity_filtered_lynxlynx <- data_diversity_pre %>% dplyr::filter (specie=="ll") %>% dplyr::filter(unique_id %in% lista_lynxlynx$unique_id)

# Ahora para pardinus:

data_diversity_pre_sm <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_sm_n019")
data_diversity_pre_do <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_do_n012")

lista_lynxpardinus <- dplyr::inner_join( data_diversity_pre_sm, data_diversity_pre_do, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::select("unique_id")

data_diversity_filtered_lynxpardinus <- data_diversity_pre %>% dplyr::filter (specie=="lp") %>% dplyr::filter(unique_id %in% lista_lynxpardinus$unique_id)

# Con los filtrados hemos perdido 251.736 unidades. Aqui entran los promotores que se han caido. 
```

## 2. Adding divergence rate

```{r}

divergence_per_unit_lynx_lynx <- read.table(paste(wd_diver, "/c_ll_ki_0090_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% dplyr::rename("informative_sites_substitutions"="informative_sites") %>% dplyr::rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_lynx <- subset(divergence_per_unit_lynx_lynx, is.na(divergence_per_unit_lynx_lynx$divergence))
# rm(empty_divergence_per_unit_lynx_lynx)

divergence_per_unit_lynx_pardinus <- read.table(paste(wd_diver, "/c_lp_sm_0298_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% dplyr::rename("informative_sites_substitutions"="informative_sites") %>% dplyr::rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_pardinus <- subset(divergence_per_unit_lynx_pardinus, is.na(divergence_per_unit_lynx_pardinus$divergence))
# rm(empty_divergence_per_unit_lynx_pardinus)

data_diversity_filtered_lynxlynx_divergence <- data_diversity_filtered_lynxlynx %>% dplyr::left_join (., divergence_per_unit_lynx_lynx)
data_diversity_filtered_lynxpardinus_divergence <- data_diversity_filtered_lynxpardinus %>%  dplyr::left_join (., divergence_per_unit_lynx_pardinus)

```

## 3. Adding GC content

```{r}

GC_content_per_unit_lynx_lynx <- read.table(paste(wd_GC, "/list_of_units_with_chr_info_in_lynx_no_duplicates.GC_content.ll.bed", sep=""), header=F, fill = TRUE) %>% dplyr::rename("scaffold"="V1", "start_cero_based"="V2", "end"="V3", "unique_id"="V4", "GC_content"="V6") %>% select(-c("V5", "V7",	"V8",	"V9",	"V10",	"V11",	"V12","V13")) 


GC_content_per_unit_lynx_pardinus <- read.table(paste(wd_GC, "/list_of_units_with_chr_info_in_lynx_no_duplicates.GC_content.lp.bed", sep=""), header=F, fill = TRUE) %>% dplyr::rename("scaffold"="V1", "start_cero_based"="V2", "end"="V3", "unique_id"="V4", "GC_content"="V6") %>% select(-c("V5", "V7",	"V8",	"V9",	"V10",	"V11",	"V12","V13")) 


data_diversity_filtered_lynxlynx_divergence_GC <- data_diversity_filtered_lynxlynx_divergence %>% dplyr::left_join (., GC_content_per_unit_lynx_lynx)
data_diversity_filtered_lynxpardinus_divergence_GC <- data_diversity_filtered_lynxpardinus_divergence %>%  dplyr::left_join (., GC_content_per_unit_lynx_pardinus)
```


## 4. Adding recombination rate

```{r}
# Ahora adjunto los datos de recombinación. 

recombination_per_unit <- read.table(paste(wd_recom, "/recombination_rate_per_unit_all_info_sorted_filtered_uniq.bed", sep=""), header=F, na.strings = c("NA", "na"))
colnames(recombination_per_unit) <- c("unique_id","recombination_rate")
recombination_per_unit$unique_id <- as.factor(recombination_per_unit$unique_id)

data_diversity_filtered <- rbind(data_diversity_filtered_lynxlynx_divergence_GC, data_diversity_filtered_lynxpardinus_divergence_GC) %>% dplyr::left_join (., recombination_per_unit, by = "unique_id")   
# Ordenar los factores. 

data_diversity_filtered$Populations <- factor (data_diversity_filtered$Populations, levels=c("Kirov","Kirov_subsampled","NE_Poland","Norway", "Andujar","Donana"))

data_diversity_filtered$chr <- factor(data_diversity_filtered$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrC2","chrB2","chrB3","chrB4","chrA3","chrD1","chrD3","chrD4","chrD2","chrF2","chrF1","chrE2","chrE1","chrX"))

data_diversity_filtered$watterson_ave <- as.numeric(data_diversity_filtered$watterson_ave)
data_diversity_filtered$watterson_sd <- as.numeric(data_diversity_filtered$watterson_sd)
data_diversity_filtered$pairwise_ave <- as.numeric(data_diversity_filtered$pairwise_ave)
data_diversity_filtered$pairwise_sd <- as.numeric(data_diversity_filtered$pairwise_sd)
data_diversity_filtered$tajimaD <- as.numeric(data_diversity_filtered$tajimaD)


# 5/6/2018
# Hemos decidido filtrar el 20% de sitios informativos/length.
# También que tengan un mínimo de 50 sitios informativos. 
# Por último tamibén quitamos los promotores que tengan menos del tamaño esperado. 
## Aquí abajo están todas las pruebecillas que he ido haciendo para al final quedarnos con los filtro que explicamos arriba. 

# Voy a nombrar como telómero 10m, 2m o centr lo que tenga más de 75% de bases como tal. 
# Ojo que : Todo lo que tiene bases como tel2m está contenido en 10m, pero por supuesto no todo lo que está en 2m está en 10m . 
# 21/06/2018 --> Despues de pensarlo, y hacer gráficas que comparaban tel 0-10 con tel 0-2 me voy a quedar solo con tel2.  
#
# uu <- filter (data_diversity, data_diversity$tel10m_percentage!=data_diversity$tel2m_percentage)

# # Porcentaje de telomericas.
# ggplot (data = data_diversity, aes(tel10m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# 
# ggplot (data = data_diversity, aes(data_diversity$tel2m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# ggplot (data = data_diversity, aes(data_diversity$centr_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# Para cada una de las unidades voy comprobando
# ggplot (data = filter (data_diversity,data_diversity$feature=="CDS" & data_diversity$length<2000), aes(informative_sites)) +
#   geom_histogram(bins=500) 
# ggplot (data = filter(data_diversity, data_diversity$feature=="CDS"), aes(x=informative_sites, y=length)) +
#   geom_point()
# ggplot (data = filter (data_diversity,data_diversity$feature=="intergenic"), aes(length)) +
#   geom_histogram(bins=1000)
# ggplot (data = filter (data_diversity,data_diversity$feature=="intron" & data_diversity$length<150000), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="5UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="3UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="lncRNA"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="ncRNA "), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="UCNE"), aes(length)) +
#   geom_histogram(bins=1000) 
### Otros sanity checks

# SANITY CHECKS:

# lncRNA <- data_diversity %>% filter (feature=="lncRNA")
# 55885 observaciones

# ggplot(lncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# sncRNA <- data_diversity %>% filter (feature=="ncRNA")
# 21043 observaciones

# ggplot(sncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# ncRNA <- inner_join(lncRNA, sncRNA, by = c("scaffold", "start_cero_based", "end", "length")) %>%  select ("scaffold", "start_cero_based", "end","feature.x","id_gene.x", "id.x", "feature.y","id_gene.y", "id.y" ) %>% unique
# Son 14 los que coinciden. 

# Algunas notas sobre los lncRNA y ncRNA
# Infernal ("INFERence of RNA ALignment") is for searching DNA sequence databases for RNA structure and sequence similarities. It is an implementation of a special case of profile stochastic context-free grammars called covariance models (CMs). A CM is like a sequence profile, but it scores a combination of sequence consensus and RNA secondary structure consensus, so in many cases, it is more capable of identifying RNA homologs that conserve their secondary structure more than their primary sequence.

# En su momento:
# He sacado graficas para tel2m y telomero de 0 a 10m y hemos decidido quedarnos con tel2m.



```
## 5. Adding deleteriousness scores

Primero me lo bajo a mi escritorio. Esto lo he cogido del script de Dani (rvis_database) en su repositorio llamado annotation. 
Esto ya está hecho así que no tengo que hacerlo ahora. 
```{bash}
scp -p mlucena@genomics-b.ebd.csic.es://GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/rvis/lypa_rvis_database_uniprot_joined.txt /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/rvis 

# Usamos la ultima db creada por dani con mas de 12000 genes anotados
```


```{r}
# Load dataframe with rvis scores
rvis_score_df <- read.table ("/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/rvis/lypa_rvis_database_uniprot_joined.txt", header=F, dec=".") %>% dplyr::rename(lynx_gene=V2, rvis_score=V5) %>% dplyr::select (lynx_gene, rvis_score)

# Los header que ha puesto dani en esta tabla son:
# CCDSr20	%geneCov	RVIS[pop_maf_0.05%(any)]	%RVIS[pop_maf_0.05%(any)]	Edge_case_RVIS[pop_maf_0.05%(any)]	OE-ratio_[ExAC v2]	%OE-ratio_[ExAC v2]	alternative-RVIS[maf_0.0025%]	alternative-%RVIS[maf_0.0025%]

# We have found that some gnes might have more than one values of deleteriousness, we are keeping the highest one. 
rvis_score_df_filtered <- aggregate(rvis_score~lynx_gene,rvis_score_df,function(x) x[which.max(abs(x))])

data_diversity_filtered_scored <- dplyr::left_join (data_diversity_filtered, rvis_score_df_filtered, by=c("id_gene"="lynx_gene"))


```

## 6. Adding selective sites density


```{r}

funcitonal_site_density_df <- read.table (paste0(wd_site_density, "windows_2Mb_density_functional_sites_per_unit.tsv"), header=F, dec=".") %>% 
  dplyr::rename(scaffold=V1, pos1_1based=V2, pos2=V3,functional_sites_percentage=V4 ) %>% 
  mutate (pos1_0based=pos1_1based-1)

data_diversity_filtered_scored_functional_sites <- dplyr::left_join (data_diversity_filtered_scored, funcitonal_site_density_df, by=c("scaffold"="scaffold", "start_cero_based"="pos1_0based", "end"="pos2")) %>% 
  select (-pos1_1based)

write.table (data_diversity_filtered_scored_functional_sites, paste(wd_out, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), row.names = F, quote = F, sep = '\t')


# Borro las que no necesito luego

rm (data_diversity_pre_sm)
rm (data_diversity_pre_do)
rm (data_diversity_pre_ki)
rm (data_diversity_pre_po)
rm (data_diversity_pre_no)
rm (data_diversity)
rm (data_diversity_filtered_lynxlynx)
rm (data_diversity_filtered_lynxpardinus)
rm (data_diversity_pre)
rm (lista_lynxlynx)
rm (lista_lynxpardinus)
rm (c_ll_ki_n013)
rm (c_ll_no_n008)
rm (c_ll_po_n008)
rm (c_lp_do_n012)
rm (c_lp_sm_n019)

```

# -------------------------------------------------

# Modifying data 2

## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(boot)
library(broom)
library(Hmisc)

wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/"
wd_output_stats <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/per_pop/"
```

## Load table 
```{r}
data_diversity_filtered <- read.table(paste(wd, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), header=T, na.strings = c("NA", "na")) %>%
  # filtramos para que tenga información de cromosoma
  filter(., !is.na(chr)) %>% 
  filter(., !is.na(region))
# En esta tabla hay valores de watterson que son 0 a pesar de ser valores que teníamos anteriormente, y que tengamos valores para pi. Esto es por la transformación de watterson para chr, y que hemos realizado. Para los autosomas, hemos dejado el valor como está y para los chr X hemos aplicado una corrección. Como en algunos casoa unque tnga valores de diversidad no tngo valores de chr, al aplicar la corrección se queda en cero. Lo que tngo que hacer ahora es filtrar para los valores que no tengan info de chr. Y eso lo hago aquí, al principio. 
```

## Modifying dataframe
## 1.  Recombination categories
```{r}
# I used a function that discritize a continious variable, based on values of the variable itself (interval), or on the frequency of units under this variable (frequency)
recomb_interval <- discretize(data_diversity_filtered$recombination_rate, method = "frequency", breaks = 20)
recomb <- substring(recomb_interval,2) %>% gsub("\\,.*","",.)
data_diversity_filtered_recomb_cat  <- cbind (data_diversity_filtered, as.data.frame(recomb))

# rm (data_diversity_filtered)
```


## 2. Density plot watterson
Now we are plotting a density plot of the diversity (watterson and pi) of the populations. Those are bimodal. Therefore I will get the lowest value of this density plot in order to stablish a threshold for "no diverse" vs "diverse" units. 
```{r}
POPS=c("c_ll_ki_n013","c_ll_no_n008", "c_ll_po_n008", "c_lp_sm_n019", "c_lp_do_n012")

for (POP in POPS)
{
DATAFRAME <- data_diversity_filtered_recomb_cat %>% dplyr::filter (pop==POP)
maxY1_position <- which.max(density(log10(DATAFRAME$watterson_ave))$y)
maxX1_value <- density(log10(DATAFRAME$watterson_ave))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$watterson_ave))$y[density(log10(DATAFRAME$watterson_ave))$x>(maxX1_value+3)])
maxY2_position <- which(density(log10(DATAFRAME$watterson_ave))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$watterson_ave))$x[maxY2_position] 
DensityWatterson.Y <- density(log10(DATAFRAME$watterson_ave))$y
DensityWatterson.X <- density(log10(DATAFRAME$watterson_ave))$x
minY_value <- min(DensityWatterson.Y[DensityWatterson.X < maxX2_value & DensityWatterson.X > maxX1_value])
minY_position <- which(DensityWatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$watterson_ave))$x[minY_position] 
# ggplot(DATAFRAME, aes(log10(watterson_ave))) + 
#   geom_density() + 
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   geom_vline(xintercept = density(log10(DATAFRAME$watterson_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_watterson.pdf"))
# 
# ggplot(DATAFRAME, aes(log10(watterson_ave))) + 
#   geom_density() + 
#   facet_wrap(~feature) +
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   geom_vline(xintercept = density(log10(DATAFRAME$watterson_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_feature_watterson.pdf"))
assign(paste0(POP,"_density_min_value_watterson"), c(POP,minX_value))
}

# Join different tables. 

density_min_values_watterson <- as.data.frame(rbind (c_lp_sm_n019_density_min_value_watterson, c_lp_do_n012_density_min_value_watterson, c_ll_ki_n013_density_min_value_watterson, c_ll_po_n008_density_min_value_watterson, c_ll_no_n008_density_min_value_watterson)) 
names(density_min_values_watterson) <- c("pop", "min_density_value_watterson")
density_min_values_watterson$min_density_value_watterson <- as.numeric(as.character(density_min_values_watterson$min_density_value_watterson))
rm (c_lp_sm_n019_density_min_value_watterson)
rm (c_lp_do_n012_density_min_value_watterson)
rm (c_ll_ki_n013_density_min_value_watterson)
rm (c_ll_po_n008_density_min_value_watterson)
rm (c_ll_no_n008_density_min_value_watterson) 
rm (DATAFRAME)
```

## 3. Density plot pairwise

```{r}
POPS=c("c_ll_ki_n013","c_ll_no_n008", "c_ll_po_n008", "c_lp_sm_n019", "c_lp_do_n012")

for (POP in POPS)
{
DATAFRAME <- data_diversity_filtered_recomb_cat %>% dplyr::filter (pop==POP)
maxY1_position <- which.max(density(log10(DATAFRAME$pairwise_ave))$y)
maxX1_value <- density(log10(DATAFRAME$pairwise_ave))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$pairwise_ave))$y[density(log10(DATAFRAME$pairwise_ave))$x>(maxX1_value+3)])
maxY2_position <- which(density(log10(DATAFRAME$pairwise_ave))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$pairwise_ave))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$pairwise_ave))$y
Densitypairwise.X <- density(log10(DATAFRAME$pairwise_ave))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X < maxX2_value & Densitypairwise.X > maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$pairwise_ave))$x[minY_position] 
# ggplot(DATAFRAME, aes(log10(pairwise_ave))) + 
#    geom_density() + 
#    scale_color_viridis(discrete=TRUE) +
#    scale_fill_viridis(discrete=TRUE) +
#    geom_vline(xintercept = density(log10(DATAFRAME$pairwise_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_pairwise.pdf"))
# 
# ggplot(DATAFRAME, aes(log10(pairwise_ave))) + 
#    geom_density() + 
#   facet_wrap (~feature)+
#    scale_color_viridis(discrete=TRUE) +
#    scale_fill_viridis(discrete=TRUE) +
#    geom_vline(xintercept = density(log10(DATAFRAME$pairwise_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_feature_pairwise.pdf"))
assign(paste0(POP,"_density_min_value_pairwise"), c(POP,minX_value))
}

# Uno las distintas tablas de puntos de corte. 

density_min_values_pairwise <- as.data.frame(rbind (c_lp_sm_n019_density_min_value_pairwise, c_lp_do_n012_density_min_value_pairwise, c_ll_ki_n013_density_min_value_pairwise, c_ll_po_n008_density_min_value_pairwise, c_ll_no_n008_density_min_value_pairwise)) 
names(density_min_values_pairwise) <- c("pop", "min_density_value_pairwise")
density_min_values_pairwise$min_density_value_pairwise <- as.numeric(as.character(density_min_values_pairwise$min_density_value_pairwise))

rm (c_lp_sm_n019_density_min_value_pairwise)
rm (c_lp_do_n012_density_min_value_pairwise)
rm (c_ll_ki_n013_density_min_value_pairwise)
rm (c_ll_po_n008_density_min_value_pairwise)
rm (c_ll_no_n008_density_min_value_pairwise) 
rm (DATAFRAME)
```

## 4. Create new variable low values to zero
Now I create a new variable replacing the diversity of units below the minimun of the density plot by 0; i.e. below the minimum value of the bimodal distributions, units are not variable, and hence, 0. 
```{r}
data_diversity_filtered_recomb_cat_zero_variable <- data_diversity_filtered_recomb_cat %>% 
  dplyr::mutate (watterson_zero = ifelse (pop=="c_lp_sm_n019"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_lp_sm_n019")$min_density_value_watterson) | 
pop=="c_lp_do_n012"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_lp_do_n012")$min_density_value_watterson) | 
pop=="c_ll_ki_n013"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_ki_n013")$min_density_value_watterson) | 
pop=="c_ll_po_n008"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_po_n008")$min_density_value_watterson) | 
pop=="c_ll_no_n008"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_no_n008")$min_density_value_watterson),0,watterson_ave)) %>% 
  dplyr::mutate (pairwise_zero = ifelse (pop=="c_lp_sm_n019"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_lp_sm_n019")$min_density_value_pairwise) | 
pop=="c_lp_do_n012"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_lp_do_n012")$min_density_value_pairwise) | 
pop=="c_ll_ki_n013"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_ki_n013")$min_density_value_pairwise) | 
pop=="c_ll_po_n008"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_po_n008")$min_density_value_pairwise) | 
pop=="c_ll_no_n008"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_no_n008")$min_density_value_pairwise),0,pairwise_ave)) %>%
  dplyr::mutate(tajimaD_transformed = ifelse(watterson_zero!="0" | pairwise_zero!="0", tajimaD, NA)) %>% select (-tajimaD) %>%  dplyr::rename(.,"tajimaD"="tajimaD_transformed")

rm (data_diversity_filtered_recomb_cat)
```

## 5. Create Skewness variable

```{r}
data_diversity_filtered_recomb_cat_zero_variable <- data_diversity_filtered_recomb_cat_zero_variable %>% 
   ## Calculate Δθw4 = 1 − π4 /θw4 (skewness SFS)
  dplyr::mutate (skewness_SFS = 1 - pairwise_ave / watterson_ave)                                   
# Where π4 and θw4 are the estimates of diversity based on the mean pairwise difference between alleles and the number of segregating sites, respectively
```

## 6. Rename & order factors
```{r}
data_diversity_filtered_recomb_cat_zero_variable$Populations <- factor (data_diversity_filtered_recomb_cat_zero_variable$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
data_diversity_filtered_recomb_cat_zero_variable$feature <- plyr::revalue(data_diversity_filtered_recomb_cat_zero_variable$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))
data_diversity_filtered_recomb_cat_zero_variable$feature <- factor (data_diversity_filtered_recomb_cat_zero_variable$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))
```
## 7. Autosomes vs chrX
Now I split my data.frame between X and autosomes. 
Consideramos como autosomicas todas aquellas posiciones que no estén en un cromosoma chrX.
```{r}
data_diversity_filtered_autosomes <- data_diversity_filtered_recomb_cat_zero_variable %>% dplyr::filter (chr!="chrX") %>% dplyr::mutate (type_chr="autosomes")
data_diversity_filtered_chrX <- data_diversity_filtered_recomb_cat_zero_variable %>% dplyr::filter (chr=="chrX") %>% dplyr::mutate (type_chr="chrX")
rm (data_diversity_filtered_recomb_cat_zero_variable)
```
## 8. Corrected with intergenic
Corrijo los valores individuales para la media de intergénico
Los datos para qcada poblacion van a tener el mismo dibujo, pero en los ratios si afecta.
Primero calculo los valores para intergénico para poder corregir por ellos, de media y mediana, pero voy a usar media para corregir. La media o mediana que uso para corregir es la sacada de los valores originales, no la que contempla los ceros, pero en realidad estos valores corregidos no se van a usar en ningún análisis posterior, aunque los dejo, por si necesitasemos usarlos en el futuro.
```{r}
# Autosomes
autosomes_intergenic_average_values <- data_diversity_filtered_autosomes  %>% dplyr::filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),
                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave),
                      # Values considering zeros.
                       mean_watterson_ave_zero_intergenic=mean(watterson_zero),
                       mean_pairwise_ave_zero_intergenic=mean(pairwise_zero),
                       median_watterson_ave_zero_intergenic=median(watterson_zero),
                       median_pairwise_ave_zero_intergenic=median(pairwise_zero))

# ChrX:
chrX_intergenic_average_values <- data_diversity_filtered_chrX  %>% dplyr::filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),
                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave),
                      # Values considering zeros.
                       mean_watterson_ave_zero_intergenic=mean(watterson_zero),
                       mean_pairwise_ave_zero_intergenic=mean(pairwise_zero),
                       median_watterson_ave_zero_intergenic=median(watterson_zero),
                       median_pairwise_ave_zero_intergenic=median(pairwise_zero))

# Saco las tablas para cada población y añado una columna en la que corrijo por la media de pairwise, per unit. 
# Los valores calculados, también me servirán a posteriori para calcular la mediana corregida. 
# Realmente aunque no vaya a usar los valores corregidos esto es util pq separo en poblaciones
POPS=c("c_ll_ki_n013","c_ll_no_n008","c_ll_po_n008", "c_lp_sm_n019","c_lp_do_n012")
for (POP in POPS)
{
  print (POP)
  # 1.- Media de intergénico por poblacion.
  ## autosomes
  autosomes_pairwise_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_watterson_ave_intergenic))
  dataframe_autosomes <-  data_diversity_filtered_autosomes %>%  dplyr::filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/autosomes_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected= watterson_ave/autosomes_watterson_average_intergenic_per_unit) 
   assign(paste(POP,"_autosomes_diversity", sep=""), dataframe_autosomes)
  rm (dataframe_autosomes)
   ## chrX
  chrX_pairwise_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_watterson_ave_intergenic))
    dataframe_chrX <-  data_diversity_filtered_chrX %>%  dplyr::filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/chrX_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected = watterson_ave/chrX_watterson_average_intergenic_per_unit) 
    assign(paste(POP,"_chrX_diversity", sep=""), dataframe_chrX)
  rm (dataframe_chrX)
}
```
## 9. Fusiono y escribo tablas
```{r}
c_ll_ki_n013_diversity <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_ki_n013_chrX_diversity ) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_ll_no_n008_diversity <- rbind (c_ll_no_n008_autosomes_diversity, c_ll_no_n008_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_ll_po_n008_diversity <- rbind (c_ll_po_n008_autosomes_diversity, c_ll_po_n008_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_lp_sm_n019_diversity <- rbind (c_lp_sm_n019_autosomes_diversity, c_lp_sm_n019_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_lp_do_n012_diversity <- rbind (c_lp_do_n012_autosomes_diversity, c_lp_do_n012_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
### Autosomas
data_diversity_autosomes_filtered_ave_corrected <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_no_n008_autosomes_diversity, c_ll_po_n008_autosomes_diversity,  c_lp_sm_n019_autosomes_diversity, c_lp_do_n012_autosomes_diversity) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
### ChrX
data_diversity_chrX_filtered_ave_corrected <- rbind (c_ll_ki_n013_chrX_diversity, c_ll_no_n008_chrX_diversity, c_ll_po_n008_chrX_diversity,  c_lp_sm_n019_chrX_diversity, c_lp_do_n012_chrX_diversity) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
# Uno ambas tablas
data_diversity_filtered_ave_corrected <- rbind (data_diversity_autosomes_filtered_ave_corrected, data_diversity_chrX_filtered_ave_corrected)
rm (data_diversity_filtered_autosomes)
rm (data_diversity_filtered_chrX)

# Las guardo para luego poder hacer más comodo las comparaciones entre poblaciones.

write.table(c_ll_ki_n013_diversity, paste(wd,"c_ll_ki_n013_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_ll_no_n008_diversity, paste(wd,"c_ll_no_n008_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_ll_po_n008_diversity, paste(wd,"c_ll_po_n008_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_lp_sm_n019_diversity, paste(wd,"c_lp_sm_n019_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_lp_do_n012_diversity, paste(wd,"c_lp_do_n012_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(data_diversity_filtered_ave_corrected, paste(wd,"data_diversity_filtered_ave_corrected.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(density_min_values_watterson, paste(wd,"density_min_values_watterson.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(density_min_values_pairwise, paste(wd,"density_min_values_pairwise.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )

```

# -----------------------------------------------------------------
# Create stats dataframes

Genero las tablas de stats

Primero creo una formula para poder calcular la stdev basada en bootstrapping.
```{r}
sample.wtd.mean <- function(x, w, d) {
    return(weighted.mean(x = x[d], w = w[d], na.rm=T ))}
```

### Summary stats per pop
Now I group the data based on population.
```{r}
diversity_stats_pop <- function(DATAFRAME)
{
  diversity_stats_df <- 
             DATAFRAME %>% 
    # Esto zero - zero lo calculo para luego poder sacar el 95% de la distribución par los GO term de interes. 
             mutate(watterson_zero_zero=ifelse(watterson_zero==0, NA,watterson_zero)) %>% 
             mutate(pairwise_zero_zero=ifelse(pairwise_zero==0, NA,pairwise_zero)) %>% 
             dplyr::group_by(Populations, pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       # Distribución sin corregir
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5 * IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5 * IQR_pairwise_ave,
                       upperw_watterson_ave = q75_watterson_ave + 1.5 * IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5 * IQR_pairwise_ave,
                       # Valores recombinación
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       #wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       # Valores divergencia
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE),
                       # Valores GC_content (no hago weighted pq no tiene sentido ya q la info esta sacada del genoma que tiene todos los sitios)
                       mean_GC_content=mean(GC_content, na.rm=TRUE),
                       # Valores Rvis
                       mean_rvis_score=mean (rvis_score, na.rm=TRUE),
                       # Valores functional sites density
                       mean_functional_sites_percentage=mean(functional_sites_percentage, na.rm=TRUE)) %>% 
    ## Calculate Δθw4 = 1 − π4 /θw4 (skewness SFS)
  dplyr::mutate (skewness = 1-wmean_pairwise_ave/wmean_watterson_ave) %>%                                    
# Where π4 and θw4 are the estimates of diversity based on the mean pairwise difference between alleles and the number of segregating sites, respectively
  mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx",
                            ifelse (Populations == "c_ll_no_n008", "L.lynx",  
                            ifelse (Populations == "Andujar", "L.pardinus", 
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))
diversity_stats_df$Populations <- factor (diversity_stats_df$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
return(diversity_stats_df)
}

# Creo las tablas
stats_df_pop_autosomes <- diversity_stats_pop(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes")) %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX <- diversity_stats_pop(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75)) %>%  mutate (type_chr="chrX") 
# Las fusiono y las guardo
stats_df_pop <- rbind (stats_df_pop_autosomes, stats_df_pop_chrX)
write.table(stats_df_pop, paste(wd_output_stats,"stats_diversity_per_pop.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
#rm (stats_df_pop_autosomes)
#rm (stats_df_pop_chrX)
```


### Summary stats per pop & different group (feature, chr, region, recomb) 
```{r}
diversity_stats_grouped <- function(DATAFRAME ,GROUP)
{ diversity_stats_df_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("Populations","pop", GROUP) %>%
             dplyr::mutate(watterson_zero_zero=ifelse(watterson_zero==0, NA,watterson_zero)) %>% 
             dplyr::mutate(pairwise_zero_zero=ifelse(pairwise_zero==0, NA,pairwise_zero)) %>% 
             dplyr::summarise(
                       total_count=n(), 
                       # Valores sin corregir
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD, na.rm = TRUE),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25, na.rm = TRUE),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75, na.rm = TRUE),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05, na.rm = TRUE),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95, na.rm = TRUE),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,
                       # Valores recombinación
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       #wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       # Valores divergencia
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE),
                       # Valores GC_content (no hago weighted pq no tiene sentido ya q la info esta sacada del genoma que tiene todos los sitios)
                       mean_GC_content=mean(GC_content, na.rm=TRUE),
                       # Valores Rvis
                       mean_rvis_score=mean (rvis_score, na.rm=TRUE),
                       # Valores functional sites density
                       mean_functional_sites_percentage=mean(functional_sites_percentage, na.rm=TRUE)) %>% 
    ## Calculate Δθw4 = 1 − π4 /θw4 (skewness SFS)
  dplyr::mutate (skewness = 1-wmean_pairwise_ave/wmean_watterson_ave) %>%                                    
# Where π4 and θw4 are the estimates of diversity based on the mean pairwise difference between alleles and the number of segregating sites, respectively
  dplyr::mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx", 
                            ifelse (Populations == "Norway", "L.lynx", 
                            ifelse (Populations == "Andujar", "L.pardinus",
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))
diversity_stats_df_grouped$Populations <- factor (diversity_stats_df_grouped$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
if("chr" %in% colnames(diversity_stats_df_grouped))
{diversity_stats_df_grouped$chr <- factor(diversity_stats_df_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
return (diversity_stats_df_grouped)
}

# Hacemos la tablas
stats_df_pop_autosomes_feature <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_feature <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "feature") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_region  <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "region") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_region  <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "region") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_chr     <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "chr") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_chr     <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "chr") %>%  mutate (type_chr="chrx")

stats_df_pop_autosomes_recomb <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "recomb") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_recomb <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "recomb") %>%  mutate (type_chr="chrX")

# Fusiono y guardo
stats_df_pop_feature <- rbind (stats_df_pop_autosomes_feature, stats_df_pop_chrX_feature)
stats_df_pop_region <- rbind (stats_df_pop_autosomes_region, stats_df_pop_chrX_region)
stats_df_pop_chr <- rbind (stats_df_pop_autosomes_chr, stats_df_pop_chrX_chr)
stats_df_pop_recomb <- rbind (stats_df_pop_autosomes_recomb, stats_df_pop_chrX_recomb)

write.table(stats_df_pop_feature, paste(wd_output_stats,"stats_diversity_per_pop_per_feature.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region, paste(wd_output_stats,"stats_diversity_per_pop_per_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr, paste(wd_output_stats,"stats_diversity_per_pop_per_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_recomb, paste(wd_output_stats,"stats_diversity_per_pop_per_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

#rm (stats_df_pop_autosomes_feature)
#rm (stats_df_pop_chrX_feature)
#rm (stats_df_pop_autosomes_region)
#rm (stats_df_pop_chrX_region)
```

###  Summary stats per pop & different group - group (feature-chr, feature-region, chr-region) 
```{r}

diversity_stats_doble_grouped <- function(DATAFRAME, GROUP1, GROUP2)
{ diversity_stats_df_doble_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("Populations","pop", GROUP1, GROUP2) %>%
             dplyr::summarise(
                       total_count=n(), 
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD, na.rm = TRUE),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25, na.rm = TRUE),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75, na.rm = TRUE),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05, na.rm = TRUE),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95, na.rm = TRUE),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,# Valores recombinación
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       #wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       # Valores divergencia
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE),
                       # Valores GC_content (no hago weighted pq no tiene sentido ya q la info esta sacada del genoma que tiene todos los sitios)
                       mean_GC_content=mean(GC_content, na.rm=TRUE),
                       # Valores Rvis
                       mean_rvis_score=mean (rvis_score, na.rm=TRUE),
                       # Valores functional sites density
                       mean_functional_sites_percentage=mean(functional_sites_percentage, na.rm=TRUE)) %>% 
    ## Calculate Δθw4 = 1 − π4 /θw4 (skewness SFS)
  dplyr::mutate (skewness = 1-wmean_pairwise_ave/wmean_watterson_ave) %>%                                 
# Where π4 and θw4 are the estimates of diversity based on the mean pairwise difference between alleles and the number of segregating sites, respectively
  mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx",
                            ifelse (Populations == "Norway", "L.lynx", 
                            ifelse (Populations == "Andujar", "L.pardinus",
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))

diversity_stats_df_doble_grouped$Populations <- factor (diversity_stats_df_doble_grouped$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
 if("chr" %in% colnames(diversity_stats_df_doble_grouped)){diversity_stats_df_doble_grouped$chr <- factor(diversity_stats_df_doble_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
return (diversity_stats_df_doble_grouped)
}

# Hacemos la tablas

stats_df_pop_autosomes_feature_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature", "chr") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_region_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),  "region", "chr") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_recomb_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),  "recomb", "chr") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_feature_region <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature", "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_feature_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature", "recomb") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_region_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "region", "recomb") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_feature_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "feature", "chr") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_region_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75),  "region", "chr") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_recomb_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75),  "recomb", "chr") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_feature_region <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "feature", "region") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_feature_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "feature", "recomb") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_region_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX") %>% filter(tel10m_percentage<0.75), "region", "recomb") %>%  mutate (type_chr="chrX")

# Fusiono y guardo
stats_df_pop_feature_chr <- rbind (stats_df_pop_autosomes_feature_chr, stats_df_pop_chrX_feature_chr)
stats_df_pop_region_chr <- rbind (stats_df_pop_autosomes_region_chr, stats_df_pop_chrX_region_chr)
stats_df_pop_recomb_chr <- rbind (stats_df_pop_autosomes_recomb_chr, stats_df_pop_chrX_recomb_chr)
stats_df_pop_feature_region <- rbind (stats_df_pop_autosomes_feature_region, stats_df_pop_chrX_feature_region)
stats_df_pop_feature_recomb <- rbind (stats_df_pop_autosomes_feature_recomb, stats_df_pop_chrX_feature_recomb)
stats_df_pop_region_recomb <- rbind (stats_df_pop_autosomes_region_recomb, stats_df_pop_chrX_region_recomb)

write.table(stats_df_pop_feature_chr, paste(wd_output_stats,"stats_diversity_per_pop_per_feature_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_chr, paste(wd_output_stats,"stats_diversity_per_pop_per_region_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_recomb_chr, paste(wd_output_stats,"stats_diversity_per_pop_per_recomb_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_feature_region, paste(wd_output_stats,"stats_diversity_per_pop_per_feature_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_feature_recomb, paste(wd_output_stats,"stats_diversity_per_pop_per_feature_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_recomb, paste(wd_output_stats,"stats_diversity_per_pop_per_region_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

#rm (stats_df_pop_autosomes_feature_region)
#rm (stats_df_pop_chrX_feature_region)

```

# -----------------------------------------------------------------
# -----------------------------------------------------------------
# START THE ANALYSIS
# -----------------------------------------------------------------

# Diversity per pop
## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(boot)
library(broom)
library(Hmisc)
library(GGally)
library(ggpmisc)

wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/per_pop/"
```

## Load data 

¡Depende de lo que vaya a correr no tengo que cargar todos los datos!

## A) Empiracal data
```{r}
data_diversity_filtered_ave_corrected <- read.table(paste(wd, "data_diversity_filtered_ave_corrected.csv", sep=""), header=T, na.strings = c("NA", "na"), row.names = NULL, stringsAsFactors = F, sep =";", dec=".") %>% 
  # No se pq no reconoce estos caracteres, así que los tengo que volver a añadir. 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA))))))

data_diversity_filtered_ave_corrected$Populations <- factor (data_diversity_filtered_ave_corrected$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
data_diversity_filtered_ave_corrected$feature <- factor (data_diversity_filtered_ave_corrected$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))
```

### Save table with common fields

```{r}
data_common_fields <- data_diversity_filtered_ave_corrected %>% select ("scaffold","start_cero_based","end","length","feature","strandness","frame","id","centr_bases" ,"centr_percentage" ,"tel10m_bases","tel10m_percentage","tel2m_bases", "tel2m_percentage", "region" , "chr", "cat_position_start", "cat_position_end", "unique_id", "id_gene", "informative_sites_substitutions", "substitutions", "divergence" , "GC_content" ,"recombination_rate", "rvis_score","recomb","functional_sites_percentage","type_chr")  %>% unique(.)

write.table(data_common_fields, paste(wd,"common_fields_per_unit",sep=""),quote = F,  row.names = F, sep =";", dec="," )

```

## B) Summarize data
```{r}
stats_df_pop <- read.table(paste(wd_output,"stats_diversity_per_pop.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T)
stats_df_pop_feature <- read.table(paste(wd_output,"stats_diversity_per_pop_per_feature.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_region <- read.table(paste(wd_output,"stats_diversity_per_pop_per_region.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_chr <- read.table(paste(wd_output,"stats_diversity_per_pop_per_chr.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_recomb <- read.table(paste(wd_output,"stats_diversity_per_pop_per_recomb.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_feature_chr <- read.table(paste(wd_output,"stats_diversity_per_pop_per_feature_chr.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_region_chr <- read.table(paste(wd_output,"stats_diversity_per_pop_per_region_chr.tsv",sep=""), row.names = NULL, sep =";", dec=",", header=T )
stats_df_pop_recomb_chr <- read.table(paste(wd_output,"stats_diversity_per_pop_per_recomb_chr.tsv",sep=""), row.names = NULL, sep =";", dec="," , header=T)
stats_df_pop_feature_region <- read.table(paste(wd_output,"stats_diversity_per_pop_per_feature_region.tsv",sep=""), row.names = NULL, sep =";", dec="," , header=T)
stats_df_pop_feature_recomb <- read.table(paste(wd_output,"stats_diversity_per_pop_per_feature_recomb.tsv",sep=""),row.names = NULL, sep =";", dec="," , header=T)
stats_df_pop_region_recomb <- read.table(paste(wd_output,"stats_diversity_per_pop_per_region_recomb.tsv",sep=""), row.names = NULL, sep =";", dec="," , header=T)

# Sort factors. 

#stats_df_pop_feature
#stats_df_pop_feature_chr
#stats_df_pop_feature_region
#stats_df_pop_feature_recomb


# tienes q cambiar el nombre de la dataframe cada vez

stats_df_pop_feature$Populations <- factor (stats_df_pop_feature$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))

stats_df_pop_feature$feature <- factor (stats_df_pop_feature$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

stats_df_pop$Populations <- factor (stats_df_pop$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))

```
## --------
# A) Empirical data

## Set up colours

```{r}
cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#FDE725FF")


cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#CC6600")
```

## *Unit size
```{r}
# Tamaño de las unidades
ggplot (data = data_diversity_filtered_ave_corrected, aes(length)) +
  geom_histogram() +
  scale_fill_viridis() +
  facet_wrap (~feature, scales = "free")
ggsave(paste (wd_output, "length_per_unit_all_pops.pdf", sep=""))

ggplot (data = data_diversity_filtered_ave_corrected %>% 
          filter (Populations=="Kirov" | Populations=="Andujar") %>% 
          filter (feature !="Gen_promoter") %>% 
          filter(feature !="lncRNA_promoter"), 
        aes(length)) +
  geom_density() +
  scale_fill_viridis() +
  facet_wrap (Species~feature, scales = "free") +
  theme(text = element_text(size=15), axis.text.x = element_text(angle = 45, hjust = 1)) +
ggsave(paste (wd_output, "length_per_unit_per_pops.pdf", sep=""), width = 16, height = 20 )


for (pop in unique(data_diversity_filtered_ave_corrected$Populations))
  {
  print (pop)
  ggplot (data=dplyr::filter(data_diversity_filtered_ave_corrected,data_diversity_filtered_ave_corrected$Populations==!!pop), aes(length)) +
  geom_histogram() +
  scale_fill_viridis() +
  facet_wrap (~feature, scales = "free") 
  ggsave(paste (wd_output, "length_per_unit_",pop,".pdf", sep="" ), device="pdf")
}

# Informative_sites
ggplot (data = data_diversity_filtered_ave_corrected %>% 
          filter (Populations=="Kirov" | Populations=="Andujar") %>% 
          filter (feature !="Gen_promoter") %>% 
          filter(feature !="lncRNA_promoter"), 
        aes(informative_sites)) +
  geom_density() +
  scale_fill_viridis() +
  facet_wrap (Species~feature, scales = "free") +
  theme(text = element_text(size=15), axis.text.x = element_text(angle = 45, hjust = 1)) +
ggsave(paste (wd_output, "informative_sites_per_unit_per_pops.pdf", sep=""), width = 16, height = 20 )
```

## *Recombination histogram

```{r}
# Hacemos un plot para ver la distribución de los valores, cogemos por ejemplo la población de kirov.
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=recombination_rate)) + 
  geom_histogram(binwidth=1, color="black", fill="white") +
  ggsave(paste (wd_output, "histogram_recombination_rate.pdf", sep=""))
```

## *Recombination and regions
```{r}

  
ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), aes(region,recombination_rate))+
  geom_boxplot() + #geom_violin
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","recombination_rate_per_region.pdf", sep="" ))


ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), aes(region,recombination_rate))+
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","recombination_rate_per_region_mean_se.pdf", sep="" ))

```

## *Divergence  histogram

```{r}
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=divergence)) + 
  geom_histogram(color="black", fill="white") +
  ggsave(paste (wd_output, "histogram_divergence.pdf", sep=""))
```

##*Divergence and regions

```{r}

ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),aes(region,divergence))+
  geom_boxplot() + #geom_violin
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","divergence_per_region.pdf", sep="" ))


ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),aes(region,divergence))+
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","divergence_per_region_mean_se.pdf", sep="" ),height = 7, width = 7)


```

## *GC content  histogram

```{r}
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=GC_content)) + 
  geom_histogram(color="black", fill="white") +
  ggsave(paste (wd_output, "histogram_GC_content.pdf", sep=""))
```

## *RVIS  histogram

```{r}
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=rvis_score)) + 
  geom_histogram(color="black", fill="white") +
  ggsave(paste (wd_output, "histogram_rvis_score.pdf", sep=""))
```

## *Functional sites density  histogram

```{r}
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=functional_sites_percentage)) + 
  geom_histogram(color="black", fill="white") +
  ggsave(paste (wd_output, "functional_sites_percentage_divergence.pdf", sep=""))
```

# ----------

# B) Summarized data
## Set up colours

```{r}
cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#FDE725FF")


cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#CC6600")
```

### Ratio X/A

(u_f^2 / f^2) = (u_a^2 / a^2) + (u_b^2 / b^2) where u_f is the uncertainty of the ratio f=a/b, u_a is the uncertainty of the variable a and u_b is the uncertainty of variable b. In your case variables a and b are arithmetic means (I guess) so the uncertainty of arithmetic means (u_a and u_b in our examples) can be again calculated using the propagation of uncertainties

u_f = sqrt((u_a^2 / a^2) + (u_b^2 / b^2)*f^2)

```{r}
# Per pop

stats_df_pop_subset <- stats_df_pop %>% 
  select (Populations, wmean_watterson_ave, se_wmean_watterson_boot, wmean_pairwise_ave, se_wmean_pairwise_boot, mean_recombination_rate, mean_divergence_rate, wmean_divergence_rate, mean_GC_content, mean_rvis_score, mean_functional_sites_percentage, type_chr) 

ratio_per_pop_per <- stats_df_pop_subset %>%
  gather(variable, value, -c(type_chr,Populations)) %>%
  unite(temp, type_chr, variable ) %>%
  spread(temp, value) %>% 
  mutate (ratio_x_a_watterson = chrX_wmean_watterson_ave / autosomes_wmean_watterson_ave) %>%
  mutate (error_ratio_x_a_watterson = 
            sqrt (
                  ( chrX_se_wmean_watterson_boot^2 / chrX_wmean_watterson_ave^2 + 
                    autosomes_se_wmean_watterson_boot^2 / autosomes_wmean_watterson_ave^2
                    ) * 
                    (chrX_wmean_watterson_ave / autosomes_wmean_watterson_ave)^2
                  )
          )%>% 
  mutate (ratio_x_a_pairwise = chrX_wmean_pairwise_ave / autosomes_wmean_pairwise_ave) %>%
  mutate (error_ratio_x_a_pairwise = 
            sqrt (
                  ( chrX_se_wmean_pairwise_boot^2 / chrX_wmean_pairwise_ave^2 + 
                    autosomes_se_wmean_pairwise_boot^2 / autosomes_wmean_pairwise_ave^2
                    ) * 
                    (chrX_wmean_pairwise_ave / autosomes_wmean_pairwise_ave)^2
                  )
          )%>% 
  mutate (ratio_x_a_divergence = chrX_mean_divergence_rate/autosomes_mean_divergence_rate) %>% 
  mutate (ratio_x_a_GC = chrX_mean_GC_content / autosomes_mean_GC_content) %>% 
  mutate (ratio_x_a_functional_sites_percentage = chrX_mean_functional_sites_percentage / autosomes_mean_functional_sites_percentage) %>% 
  mutate (ratio_x_a_recombination_rate = chrX_mean_recombination_rate / autosomes_mean_recombination_rate) %>% 
  mutate (ratio_x_a_rvis_score = chrX_mean_rvis_score / autosomes_mean_rvis_score) 

write.table (ratio_per_pop_per, paste0 (wd_output,"ratio_x_a_per_pop.txt"), row.names = F, quote = F) 

# Per pop & feature

stats_df_pop_feature_subset <- stats_df_pop_feature %>% 
  select (Populations, feature, wmean_watterson_ave, se_wmean_watterson_boot, wmean_pairwise_ave, se_wmean_pairwise_boot, mean_recombination_rate, mean_divergence_rate, wmean_divergence_rate, mean_GC_content, mean_rvis_score, mean_functional_sites_percentage, type_chr) %>% 
  filter (feature=="CDS" | feature=="Intron" | feature =="Intergenic") 

ratio_per_pop_per_feature <- stats_df_pop_feature_subset %>%
  gather(variable, value, -c(type_chr,Populations,feature)) %>%
  unite(temp, type_chr, variable ) %>%
  spread(temp, value) %>% 
  mutate (ratio_x_a_watterson = chrX_wmean_watterson_ave / autosomes_wmean_watterson_ave) %>%
  mutate (error_ratio_x_a_watterson = 
            sqrt (
                  ( chrX_se_wmean_watterson_boot^2 / chrX_wmean_watterson_ave^2 + 
                    autosomes_se_wmean_watterson_boot^2 / autosomes_wmean_watterson_ave^2
                    ) * 
                    chrX_wmean_watterson_ave / autosomes_wmean_watterson_ave)) %>% 
  mutate (ratio_x_a_pairwise = chrX_wmean_pairwise_ave / autosomes_wmean_pairwise_ave) %>%
  mutate (error_ratio_x_a_pairwise = 
            sqrt (
                  ( chrX_se_wmean_pairwise_boot^2 / chrX_wmean_pairwise_ave^2 + 
                    autosomes_se_wmean_pairwise_boot^2 / autosomes_wmean_pairwise_ave^2
                    ) * 
                    chrX_wmean_pairwise_ave / autosomes_wmean_pairwise_ave)) %>% 
  mutate (ratio_x_a_divergence = chrX_mean_divergence_rate/autosomes_mean_divergence_rate) %>% 
  mutate (ratio_x_a_GC = chrX_mean_GC_content / autosomes_mean_GC_content) %>% 
  mutate (ratio_x_a_functional_sites_percentage = chrX_mean_functional_sites_percentage / autosomes_mean_functional_sites_percentage) %>% 
  mutate (ratio_x_a_recombination_rate = chrX_mean_recombination_rate / autosomes_mean_recombination_rate) %>% 
  mutate (ratio_x_a_rvis_score = chrX_mean_rvis_score / autosomes_mean_rvis_score) 
  
write.table (ratio_per_pop_per_feature, paste0 (wd_output,"ratio_x_a_per_pop_per_feature.txt"), row.names = F, quote = F) 


```

## *Plot ratio per pop per feature

```{r}
a_value <-ratio_per_pop_per_feature %>% select (Populations, feature, ratio_x_a_watterson, ratio_x_a_pairwise) %>% 
  gather("Type", "Value",-c(Populations, feature)) 
a_error <-ratio_per_pop_per_feature %>% select (Populations, feature, error_ratio_x_a_watterson, error_ratio_x_a_pairwise) %>% 
  rename(ratio_x_a_watterson=error_ratio_x_a_watterson, ratio_x_a_pairwise=error_ratio_x_a_pairwise) %>% 
  gather("Type", "Error",-c(Populations, feature)) 
a <- full_join(a_value, a_error)
b <- ratio_per_pop_per_feature %>% select (Populations, feature, ratio_x_a_divergence, ratio_x_a_GC, ratio_x_a_functional_sites_percentage, ratio_x_a_recombination_rate, ratio_x_a_rvis_score) %>% filter (Populations=="Kirov" ) %>% 
  gather("Type", "Value",-c(Populations, feature)) 

ggplot (a, aes(feature, Value)) +
  geom_col (aes(colour=feature, fill=feature)) +
   geom_errorbar (aes(x = feature, ymin = Value-Error, ymax = Value+Error, width=0.4)) +
  facet_wrap(Type~Populations,scales = "free_x",nrow=2) +
  theme(legend.position="bottom") +
  ggsave (paste0(wd_output,"plot_ratio_per_pop_diversity.pdf"), width = 80, height = 110, units = "mm")

ggplot (b, aes(feature, Value, colour=feature, fill=feature)) +
  geom_col () +
  # Añadir barra de error
  facet_wrap(Type~Populations,scales = "free_x",nrow=5) +
#  ggsave (plot_ratio_per_pop_diversity)
```


## *Plot diversity per pop

```{r}
 stats_df_pop_reshape1<- stats_df_pop %>% filter(type_chr=="autosomes") %>% select (Populations,wmean_watterson_ave,wmean_pairwise_ave) %>% tidyr::gather(., 'wmean_watterson_ave','wmean_pairwise_ave', key="diversity_measure",value="diversity_value"  )

 stats_df_pop_reshape2<- stats_df_pop %>% filter(type_chr=="autosomes") %>% select (Populations,se_wmean_watterson_boot, se_wmean_pairwise_boot) %>% tidyr::gather(., 'se_wmean_watterson_boot','se_wmean_pairwise_boot', key="stdev_measure",value="stdev"  )

stats_df_pop_reshape <-full_join(stats_df_pop_reshape1, stats_df_pop_reshape2) %>% 
  mutate (filtro= ifelse (diversity_measure=="wmean_watterson_ave" & stdev_measure=="se_wmean_watterson_boot",
                          1,  ifelse (diversity_measure=="wmean_pairwise_ave" & stdev_measure=="se_wmean_pairwise_boot", 1, 2))) %>% filter (filtro==1) 

# Bar

ggplot() + 
  geom_bar (data=subset(stats_df_pop_reshape), 
              aes(x=Populations, y=diversity_value, fill=Populations, colour=Populations),stat = "identity") +
  geom_errorbar (data=subset(stats_df_pop_reshape), aes(x = Populations, ymin = diversity_value-stdev, ymax = diversity_value+stdev, width=0.4))  +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  coord_flip() +
  facet_wrap(~diversity_measure, strip.position = "bottom") +
  scale_x_discrete(limits = rev(levels(stats_df_pop$Populations))) +
   theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="none", legend.title = element_blank(),axis.title.x=element_blank()) +
  ggsave(paste(wd_output,"autosomes_per_pop_bar.pdf",sep=""), width = 80, height = 40, units = "mm")




# Point
  

ggplot() + 
  geom_point (data=subset(stats_df_pop %>% filter(type_chr=="autosomes")), 
              aes(x=Populations, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop %>% filter(type_chr=="autosomes")), 
                aes(x = Populations, xend=Populations, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="none", legend.title = element_blank()) +
  coord_flip() +
  scale_x_discrete(limits = rev(levels(stats_df_pop$Populations)))
  ggsave(paste(wd_output,"watterson_autosomes_per_pop_point.pdf",sep=""), width = 80, height = 100, units = "mm")

ggplot() + 
  geom_point (data=subset(stats_df_pop %>% filter(type_chr=="autosomes")), 
              aes(x=Populations, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop %>% filter(type_chr=="autosomes")), 
                aes(x = Populations, xend=Populations, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="none", legend.title = element_blank()) +
  coord_flip() +
  scale_x_discrete(limits = rev(levels(stats_df_pop$Populations)))
  ggsave(paste(wd_output,"pairwise_autosomes_per_pop_point.pdf",sep=""), width = 80, height = 100, units = "mm")
  
  
  
```



## *Recombination and diversity

Not run
```{r}
ggplot() +
  geom_point (data=subset(stats_df_pop_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)),
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)),
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_autosomes.pdf",sep=""))

ggplot() +
  geom_point (data=subset(stats_df_pop_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)),
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)),
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_autosomes.pdf",sep=""))


ggplot() +
  geom_point (data=subset(stats_df_pop_recomb %>% filter (type_chr=="chrX"), !is.na(discrete_recomb)),
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_recomb %>% filter (type_chr=="chrX"), !is.na(discrete_recomb)),
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_chrX.pdf",sep=""))


ggplot() +
  geom_point (data=subset(stats_df_pop_recomb %>% filter (type_chr=="chrX"), !is.na(discrete_recomb)),
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_recomb %>% filter (type_chr=="chrX"), !is.na(discrete_recomb)),
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_chrX.pdf",sep=""))

```

## *Recombination and regions
Not run
```{r}

ggplot() + 
  geom_point (data=subset(stats_df_pop_region_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_region_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Populations, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_region.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_region_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_region_recomb %>% filter (type_chr=="autosomes"), !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Populations, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_region.pdf",sep=""))
  
  


```

## *Recombination and features
Not run
```{r}
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="autosomes") , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="autosomes"), !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_feature_autosomes.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="autosomes") , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="autosomes"), !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_feature_autosomes.pdf",sep=""))
  
  
  ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="chrX") , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="chrX") , !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_feature_chrX.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="chrX")  , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_feature_recomb %>% filter(type_chr=="chrX") , !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_feature_chrX.pdf",sep=""))

   
```


## *Features and diversity

```{r}
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature %>% filter(type_chr=="autosomes"), !is.na(feature)), 
              aes(x=feature, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature %>% filter(type_chr=="autosomes"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations, width=0.4)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"feature_categories_vs_watterson_autosomes.pdf",sep=""), width = 80, height = 100, units = "mm")


ggplot() + 
  geom_point (data=subset(stats_df_pop_feature %>% filter(type_chr=="autosomes"), !is.na(feature)), 
              aes(x=feature, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature %>% filter(type_chr=="autosomes"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations, width=0.4)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"feature_categories_vs_pairwise_autosomes.pdf",sep=""), width = 80, height = 100, units = "mm")

  
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature %>% filter(type_chr=="chrX"), !is.na(feature)), 
              aes(x=feature, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature %>% filter(type_chr=="chrX"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) + theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"feature_categories_vs_watterson_chrX.pdf",sep=""), width = 80, height = 100, units = "mm")


ggplot() + 
  geom_point (data=subset(stats_df_pop_feature %>% filter(type_chr=="chrX"), !is.na(feature)), 
              aes(x=feature, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature %>% filter(type_chr=="chrX"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"feature_categories_vs_pairwise_chrX.pdf",sep=""), width = 80, height = 100, units = "mm")

```

## *Features and regions

```{r}

ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_region %>% filter(type_chr=="autosomes"), !is.na(feature)), 
              aes(x=feature, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature_region %>% filter(type_chr=="autosomes"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Species, ncol=2, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"feature_categories_vs_watterson_per_region.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_region %>% filter(type_chr=="autosomes"), !is.na(feature)), 
              aes(x=feature, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature_region %>% filter(type_chr=="autosomes"), !is.na(feature)), 
                aes(x = feature, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Species, ncol=2, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"feature_categories_vs_pairwise_per_region.pdf",sep=""))
```

## *Features and chr

```{r}

ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_chr , !is.na(feature)), 
              aes(x=feature, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature_chr , !is.na(feature)), 
                aes(x = feature, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~chr,  scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"feature_categories_vs_watterson_per_chr.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_feature_chr , !is.na(feature)), 
              aes(x=feature, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_feature_chr, !is.na(feature)), 
                aes(x = feature, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~chr, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"feature_categories_vs_pairwise_per_chr.pdf",sep=""))

```



## *Region and diversity


```{r}
ggplot() + 
  geom_point (data=subset(stats_df_pop_region %>% filter(type_chr=="autosomes"), !is.na(region)), 
              aes(x=region, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_region %>% filter(type_chr=="autosomes"), !is.na(region)), 
                aes(x = region, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"region_categories_vs_watterson_autosomes.pdf",sep=""))


ggplot() + 
  geom_point (data=subset(stats_df_pop_region %>% filter(type_chr=="autosomes"), !is.na(region)), 
              aes(x=region, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_region %>% filter(type_chr=="autosomes"), !is.na(region)), 
                aes(x = region, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"region_categories_vs_pairwise_autosomes.pdf",sep=""))

```

## *Chr and diversity

```{r}
ggplot() + 
  geom_point (data=subset(stats_df_pop_chr , !is.na(chr)), 
              aes(x=chr, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_chr, !is.na(chr)), 
                aes(x = chr, ymin = wmean_watterson_ave-se_wmean_watterson_boot, ymax = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"chr_vs_watterson.pdf",sep=""), width = 80, height = 100, units = "mm")

ggplot() + 
  geom_point (data=subset(stats_df_pop_chr , !is.na(chr)), 
              aes(x=chr, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_errorbar (data=subset(stats_df_pop_chr, !is.na(chr)), 
                aes(x = chr, ymin = wmean_pairwise_ave-se_wmean_pairwise_boot, ymax = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),  legend.position="top", legend.title = element_blank())
  ggsave(paste(wd_output,"chr_vs_pairwise.pdf",sep=""), width = 80, height = 100, units = "mm")
  
```


# ---------------------------------------

## Cat info join

A nivel de chr podemos sacar muchas cosillas. Vamos a hacer un join de las tablas de información con las de diversidad y vamos a plotear algunas cosillas básicas.

```{r}
# Cargo la tabla con la información de gato.
cat_chr_info <- read.table("/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/cat_chr_gene_content_recombination_all_information.txt", header=T, na.strings = c("NA", "na"), dec=",")

# Creo tablas con la información de diversidad y de cromosomas. 
stas_df_pop_chr_plus_cat_info <- right_join(x = cat_chr_info, y = stats_df_pop_chr, by="chr") 
stas_df_pop_chr_plus_cat_info$pop <- factor (stas_df_pop_chr_plus_cat_info$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))

# como la divergencia es la única variable distinta entre sps, la hacemos dos columnas, y así sacamos solo un plot para todo, y no tenemos que sacar un plot para cada especie, cuando todas las demás son iguales en las dos species. 

average_divergence_per_pop <- stas_df_pop_chr_plus_cat_info %>% 
  filter (Populations=="Kirov" | Populations=="Andujar") %>% 
  select (Species, mean_divergence_rate, chr) %>% 
  tidyr::spread(., Species, mean_divergence_rate ) %>% 
  dplyr::rename(., "L.lynx_divergence"="L.lynx") %>%   dplyr::rename(.,"L.pardinus_divergence"="L.pardinus") 
# Filtro la tabla para que solo tenga una población y eliminamos esa columna y la unimos con la divergencia calculada antes.


```
### General plots cat info

```{r}
# La filtro para hacer plots
cat_chr_info_filtered <- stas_df_pop_chr_plus_cat_info %>%  
  full_join (., average_divergence_per_pop, by="chr") %>%
  filter(., chr!="chrX") %>% 
  select ( SizeMb_v8, GC_content, percentage_genes, cM.Mb, L.lynx_divergence, L.pardinus_divergence, mean_functional_sites_percentage, mean_rvis_score, mean_GC_content) %>% 
  unique()


# Hago una matriz de correlación entre las variables
res <- cor(cat_chr_info_filtered )
round(res, 2)
cor(cat_chr_info_filtered, use = "complete.obs")

# http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software
lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "black") +
    geom_smooth(method = method, color = "black", ...) 
  p
}

pdf(paste(wd_output, "correlation_matrix_1.pdf", sep="")) 
ggpairs(cat_chr_info_filtered,  lower = list(continuous = wrap(lowerFn, method = "lm")))
dev.off()
```

### Plot join with diversity data

```{r}
# Para todo esto quitamos el cromosoma X porque es un outlier!!!
#### SANITY CHECKS #### 
# Comprobamos que la tasa de recombinación que nosotros tenemos para cada cromosoma cuando hacemos la media es parecida a la de los cromosomas. 
# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, mean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, wmean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes(mean_recombination_rate, SizeMb_v8))+
#   geom_point() +
#     geom_smooth()
# Coincide regulín. 
######################## 


cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#CC6600")
#FDE725FF

my.formula <- y ~ x
INDEXES=c("mean_watterson_ave", "mean_pairwise_ave") 
max((stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"))$mean_watterson_ave)
                                                                    
# Diversidad vs tamaño
for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("SizeMb_v8", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(~pop) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE, label.y = 0.1) +
  theme(legend.position = c(1, 0),
       legend.justification = c(1, 0))
#theme selection for background and lines
  ggsave(paste(wd_output, "cat_size_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")
}
    
# Diversidad vs gene content

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("percentage_genes", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm",aes(fill=Populations , colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(pop~.) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
  theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))
#theme selection for background and lines
  ggsave(paste(wd_output, "cat_gene-content_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")
}
    
# Diversidad vs chr recombination
for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("cM.Mb", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(pop~.) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
      theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))
  ggsave(paste(wd_output, "cat_chr-recomb_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")

}

# Diversidad vs GC content

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("GC_content", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(pop~.) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
  theme(legend.position = c(1, 0),
  legend.justification = c(1, 0))
  ggsave(paste(wd_output, "cat_GC_content_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")

}

# Diversidad vs divergence

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("wmean_divergence_rate", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(pop~.) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(angle = 90))+
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
  ggsave(paste(wd_output, "divergence_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")
}


# Diversidad vs RVIS

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("mean_rvis_score", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(pop~.) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(angle = 90))+
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
  ggsave(paste(wd_output, "RVIS_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")
}

# Diversidad vs functional sites percentage

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_cat_info %>% filter(chr!="chrX"), aes_string("mean_functional_sites_percentage", INDEX)) +
  geom_point(aes(fill=Populations , colour=Populations)) +
  geom_smooth(method = "lm", aes(fill=Populations , colour=Populations)) +
  facet_wrap(pop~.) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  theme(axis.text.x = element_text(angle = 90))+
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.1) +
  ggsave(paste(wd_output, "fucntional_sites_vs_",INDEX,".pdf", sep=""), width = 180, height = 180, units = "mm")
}

```

### Plot R^2 & a. 

```{r}
INDEXES=c("mean_watterson_ave", "mean_pairwise_ave") 
POPULATIONS=c("Kirov","Norway","NE_Poland", "Donana", "Andujar")

data_watterson <- stas_df_pop_chr_plus_cat_info %>% 
  filter (chr!="chrX") %>% 
  dplyr::select ("wmean_divergence_rate", "GC_content", "cM.Mb", "percentage_genes", "SizeMb_v8", "mean_watterson_ave", "Populations", "mean_functional_sites_percentage","mean_rvis_score" )  %>% ungroup()

data_pairwise <- stas_df_pop_chr_plus_cat_info %>% 
  filter (chr!="chrX") %>% 
  dplyr::select ("wmean_divergence_rate", "GC_content", "cM.Mb", "percentage_genes", "SizeMb_v8", "mean_pairwise_ave", "Populations", "mean_functional_sites_percentage","mean_rvis_score" ) %>% ungroup()

tableR2sW = list()
tableR2sP = list()
tablepredictW = list()
tablepredictP = list()

i=1
for (POP in POPULATIONS)
{

  # Table prep:
  
data_watterson_per_pop <- data_watterson %>% 
    dplyr::filter(Populations==POP) %>%  
    dplyr::select (-Populations) %>% ungroup()
 
data_pairwise_per_pop <- data_pairwise %>% 
    dplyr::filter(Populations==POP) %>%  
    dplyr::select (-Populations) %>% ungroup()
 
# R squared 
r2sw <- data_watterson_per_pop %>% 
    dplyr::select(-mean_watterson_ave) %>%  # exclude outcome, leave only predictors 
    purrr::map(~lm(data_watterson_per_pop$mean_watterson_ave ~ .x, data = data_watterson_per_pop)) %>% 
    purrr::map(summary) %>% 
    purrr::map_dbl("r.squared") %>% 
    tidy %>% 
    dplyr::arrange(desc(x)) %>% 
    rename(r.squared = x) %>% 
    mutate(pop=POP) %>% 
    mutate(index="Watterson")
  
 r2sp <- data_pairwise_per_pop %>% 
    dplyr::select(-mean_pairwise_ave) %>%  # exclude outcome, leave only predictors 
    purrr::map(~lm(data_pairwise_per_pop$mean_pairwise_ave ~ .x, data = data_pairwise_per_pop)) %>% 
    purrr::map(summary) %>% 
    purrr::map_dbl("r.squared") %>% 
    tidy %>% 
    dplyr::arrange(desc(x)) %>% 
    rename(r.squared = x) %>% 
    mutate(pop=POP) %>% 
    mutate(index="Pi")
  
# Predictor
predict1w <- data_watterson_per_pop %>% 
  dplyr::select(-mean_watterson_ave) %>%  # exclude outcome, leave only predictors 
  purrr::map(~lm(data_watterson_per_pop$mean_watterson_ave ~ .x, data = data_watterson_per_pop)) %>% 
  purrr::map(summary) %>% 
  purrr::map(broom::tidy) %>% 
  purrr::map_df("estimate")  %>% 
  mutate(variable = c("intercept", "predictor")) %>% 
  filter (variable=="predictor" )%>% 
  select (-variable)
predict2w <- as_tibble(cbind(names = names(predict1w), t(predict1w)), validate = TRUE) %>% 
  mutate(pop=POP) %>% 
  mutate(index="Watterson") %>% 
  rename(., predictor = V2)

predict2w$predictor <- as.numeric(predict2w$predictor)

predict1p <- data_pairwise_per_pop %>% 
  dplyr::select(-mean_pairwise_ave) %>%  # exclude outcome, leave only predictors 
  purrr::map(~lm(data_pairwise_per_pop$mean_pairwise_ave ~ .x, data = data_pairwise_per_pop)) %>% 
  purrr::map(summary) %>% 
  purrr::map(broom::tidy) %>% 
  purrr::map_df("estimate")  %>% 
  mutate(variable = c("intercept", "predictor")) %>% 
  filter (variable=="predictor" ) %>% 
  select (-variable)

predict2p <- as_tibble(cbind(names = names(predict1p), t(predict1p)), validate = TRUE) %>% 
  mutate(pop=POP) %>% 
  mutate(index="Pi") %>% 
  rename(., predictor = V2)

predict2p$predictor <- as.numeric(predict2p$predictor)

    tableR2sW[[i]] <- r2sw # add it to your list
    tableR2sP[[i]] <- r2sp # add it to your list
    tablepredictW[[i]] <- predict2w # add it to your list
    tablepredictP[[i]] <- predict2p # add it to your list

i=i+1
}

all_popsr2 = full_join(do.call(rbind, tableR2sW), do.call(rbind, tableR2sP))
all_popspredict = full_join(do.call(rbind, tablepredictW), do.call(rbind, tablepredictP)) 

# Normalize predictor, to make values comparable
all_popspredictN_normalize_per_variable <- all_popspredict %>% 
group_by(index,names) %>% 
  mutate(predictorN = predictor / mean(predictor))


all_popspredictN_normalize_per_pop <- all_popspredict %>% 
group_by(index,pop) %>% 
  mutate(predictorN = predictor / mean(predictor))


# Normalize Rsquare, to make values comparable
all_popsr2N_normalize_per_variable <- all_popsr2 %>% 
group_by(index,names) %>% 
  mutate(r.squaredN = r.squared / mean(r.squared))

# Order factor
all_popspredict$pop <- factor (all_popspredict$pop, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
all_popspredictN_normalize_per_variable$pop <- factor (all_popspredictN_normalize_per_variable$pop, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
all_popspredictN_normalize_per_pop$pop <- factor (all_popspredictN_normalize_per_pop$pop, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))

all_popsr2$pop <- factor (all_popsr2$pop, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
all_popsr2N_normalize_per_variable$pop <- factor (all_popsr2N_normalize_per_variable$pop, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))


# Plot
ggplot(data = data.frame(all_popsr2), aes(x = pop, y = names, fill= r.squared)) + 
  geom_tile() +
  facet_wrap(~index) +
  scale_fill_gradient(low = "white", high = "dodgerblue4")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave(paste(wd_output, "all_popsr2N_no_normalized_heatmap.pdf", sep=""), width = 160, height = 160, units = "mm")

ggplot(data = data.frame(all_popsr2N_normalize_per_variable), aes(x = pop, y = names, fill= r.squaredN)) + 
  geom_tile() +
  facet_wrap(~index) +
  scale_fill_gradient(low = "white", high = "dodgerblue4")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave(paste(wd_output, "all_popsr2N_normalized_per_variable_heatmap.pdf", sep=""), width = 160, height = 160, units = "mm")


ggplot(data = data.frame(all_popspredict), aes(x = pop, y = names, fill= predictor)) + 
  geom_tile() +
  facet_wrap(~index) +
  scale_fill_gradient(low = "white", high = "dodgerblue4")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
 # geom_text(aes(label=formatC(predictor, format = "e", digits = 2),angle=45))
ggsave(paste(wd_output, "all_popspredictN_no_normalized_heatmap.pdf", sep=""), width = 160, height = 160, units = "mm")

ggplot(data = data.frame(all_popspredictN_normalize_per_variable), aes(x = pop, y = names, fill= predictorN)) + 
  geom_tile() +
  facet_wrap(~index) +
  scale_fill_gradient(low = "white", high = "dodgerblue4")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
 # geom_text(aes(label=formatC(predictor, format = "e", digits = 2),angle=45))
ggsave(paste(wd_output, "all_popspredictN_normalized_per_variable_heatmap.pdf", sep=""), width = 160, height = 160, units = "mm")


ggplot(data = data.frame(all_popspredictN_normalize_per_pop), aes(x = pop, y = names, fill= predictorN)) + 
  geom_tile() +
  facet_wrap(~index) +
  scale_fill_gradient(low = "white", high = "dodgerblue4")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
 # geom_text(aes(label=formatC(predictor, format = "e", digits = 2),angle=45))
ggsave(paste(wd_output, "all_popspredictN_normalized_per_pop_heatmap.pdf", sep=""), width = 160, height = 160, units = "mm")

```

